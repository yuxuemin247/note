###### 1、`mysql`优化

`MySQL`是一个支持插件式存储引擎的数据库系统

确定瓶颈在`MySQL`，

- 单机优化
  - 1.优化表设计，调整结构
    
    - 大表拆小表，尽量保持小表。把可变的数据和不可变的数据分开，大字段和小字段分开
    - 增加冗余字段，节约计算（违反第三范式）
  - 2.分析优化`SQL`语句
    - 利用`mysql`的慢查询日志，打开慢查询拿这些语句分析优化
    
      - ```
        -  慢查询日志记录所有执行时间超过long_query_time秒的所有查询或者不使用索引的查询
        - `MySQL`日志系统 包括错误日志、通用日志、二进制日志（记录所有更改数据的语句，还用于复制）、慢查询日志.默认情况下所有日志创建于mysqld数据目录中
        启动slow log
        my.conf配置文件中 log-slow-queries[=file_name]
        常用工具：mysqldumpslow
        ```
    
    - 比如连接(join)查询代替子查询(sub-Queries)
  - 3.索引优化
    
    - 建好索引，根据我们的where条件去建,尽量不要对数据库中某个含有大量重复值的字段建索引
  - 4.修改表和排序的缓存值，修改`my.cnf`配置
  - 5.更换更高效的存储引擎 ： `MyISM > InnoDB >xtraDB`(5%-10%)
  - 6.`Scale Up` 硬件升级，升级内存，升级存储，见效最快
  - 7.更换系统`malloc`的库,提升性能   （`zlib/ Jemalloc /tcmalloc`)
  
- 多机优化

  ​	看下业务类型，业务的读写比例

  ​	buffer是即将要被写入磁盘的  而cache是被从磁盘中读出来的

  - 读密集

    加读缓存，用`NoSQL`做Cache

    `memcache` 和`redis`区别

    - `memcache`纯内存，没有写盘的工作，设有缓存大小,超过大小，key会丢失，`memcache`是一种比`redis`更易失的不可靠缓存
    - `redis`主要用内存，内存不够会写盘，性能会急剧下降

  - 写密集

    加写缓冲buffer，在真正写库之前，先写到一个高速的中间层，然后再合并写入数据库.

    一个常见的写缓冲 `ttserver`

  - `Sharding`/分库分表/水平拆分

    前提：业务很少有跨表的全表操作

    把一个大表里的数据，按照一个规则分散到多个结构相同，但名字后缀不同的小表中，

    规则：hash （数据要求尽量均匀），hash后取后两位 

    ​			`datatime` ：最近使用效率高   订单

    ​			`geo_location ` ：数据有地理分布特性

  - `MySQL`读写分离

    主机Master用来做数据写入，从机Slave用来数据读取

    - 常见结构：
      - 一主多从，主从通过`binlog`进行数据同步
      - 双主多从，`3M`架构

    - 读写分离
      - 程序自身实现读写分离
        - 客户端自行管理
      - 使用第三方代理工具，服务器实现
        - `mysql_proxy`
        - `jd`也发布了一个数据库代理服务器

- 直接使用云数据库

  -  阿里云的  `OcenanBase`  :`TPC top 1`
  - `TiDB`等国产新兴分布式数据库,一键水平伸缩

###### 2、分布式数据库的ID

​	必须保证全服多机上产生的ID唯一，否则会产生主键冲突

​	常见全局唯一ID生成策略：

​			1.`UUID4`  、 `GUID`算法生成

​			2.`snowflake` 生成

​			3.可以使用`redis`一个表记录当前最新ID,借助`incr`指令,`incr`指令是原子的

- `mysql`自身没有乐观锁，我们可以用版本号

###### 3、数据库三范式

  -   列的原子性，不能拆分
  -   记录的唯一性
  -   字段的无冗余性，不能派生。就是不能通过其他字段计算出来（这个我们可能为了效率违反）
  -   还有四五六等等范式，范式越多，效率越差

###### 4、`redis`

```
list 列表、链表
	应用消息队列
set  集合 一堆不重复的值,redis提供了两个集合的交集并集，
	应用：两人的共同好友
		 唯一性，统计访问网站的所有独立IP
zset 有序集合
	应用：游戏积分榜

地理位置计算：
	直接利用API接口
	redis地理位置
Redis中三种特殊的数据类型（BitMap,Geo,HyperLogLog)
Geo 可以将经纬度添加到指定的键里面，之后可以计算两个点的距离。或者计算以某点为中心，范围内的点
HyperLogLog
	基数统计 ：这个结构可以非常省内存的去统计各种计数，比如注册IP数，每日访问IP数，页面实时Uv、在线用户数等。但是它有局限性，就是只能统计数量，而没有办法知道具体的内容是什么。
```

###### 5、`redis`和`memcache`的区别

- 数据结构

  `redis`支持string、list、hash、set、`zset`

  `memcache`支持`kv`这种简单存储

- 持久化

  `redis`支持`RDB`和`AOF`两种方式的持久化

  `memcache`是纯的内存存储，不支持持久化

- 内存管理上

  `redis`采用申请内存的方式，当数据超过物理内存时，会引发swap,将数据刷到硬盘上

  `memcache`使用预分配池管理，数据超过物理内存时，就会数据丢失。`memcache`在存储速度上比`redis`快一点、

- 集群

  `redis`天然支持高可用集群，支持主从

  `memcache`需要自己实现类似一致性hash的负载均衡算法才能解决集群的问题，扩展性比较低。

总结：`redis`比`memcache`功能更全，集成更方便，`memcache`在内存、线程、IO角度有一定的优势

​			`memcache`更像缓存，`redis`偏向类似数据库

6、`redis`和`RabbitMQ`做消息队列区别

- `redis`是一个key-value的非关系型数据库，但它本身支持`MQ`功能，所以可以做一个轻量级的消息队列

  `RabbitMQ`是基于`AMQP`的实现,服务端用`erlang`语言编写，用在分布式系统中存储转发消息

  消息队列中间间主要用于组件之间的解耦，消息的发送者和消息使用者无需知道对方的存在。

  应用：流量削峰：如秒杀场景 用`redis`里面的链表，然后秒杀开始后，只保存前1000个请求 操作`ltrim key 1 1000`

- 可靠消费

  `Redis` 没有相应的机制保证消息的消费，当消费者消费失败，消息体丢失

  `RabbitMQ` 具有消息确认，消费者消费完消息后发送一个回执(`Message acknowlegment`) 给`RabbitMQ`,否则自动将消息体返回原队列。如果没有收到回执且消费者的连接断开，才会将此消息发送给其他消费者，并没有timeout概念

  这里我们开发人员在处理完业务逻辑后，不要忘记发送回执给`RabbitMQ`,这将会导致严重的BUG-Queue中堆积的消息越来越多，消费者重启后会重复消费这些消息并重复执行业务逻辑

- 持久化

  `Redis`将整个`Redis`实例持久化到磁盘

  `RabbitMQ` 队列和消息都可以选择是否持久化

  ```
  - 在声明queue的时候,持久化 (durable = True)			
  - 生产者端, 需要加上下面的代码:
  				properties=pika.BasicProperties(
  					delivery_mode=2,  # make message persistent
  				)			
  - 消费者端:
  		auto_ack = False  #接到消息
  ```

- 可靠发布

  `redis`不提供，需自行实现

  `RabbitMQ` Confirm机制

  如果设置channel为confirm状态，则通过channel发送的消息会被分配一个唯一的ID,消息被正确的路由匹配到Queue,服务器会返回生产者一个Confirm，该Confirm包含该消息的ID。对于持久化消息，只有该消息被持久化，才会返回Confirm。 Confirm机制的最大优点在于异步，生产者在发送消息以后，即可继续执行其他任务。而服务器返回Confirm后，会触发生产者的回调函数，生产者在回调函数中处理Confirm信息。如果消息服务器发生异常，导致该消息丢失，会返回给生产者一个`nack`，表示消息已经丢失，这样生产者就可以通过重发消息，保证消息不丢失。

  `AMQP`也可以使用事务，但也将客户端与消息服务器同步起来，违背了消息队列解耦的本质

- 高可用

  `Redis`采用主从模式，读写分离，但是故障转移还没有完善的官方解决方案

  `RabbitMQ`集群采用磁盘、内存节点，任意单点故障都不会影响整个队列的操作

- `RabbitMQ`还支持负载均衡、流量控制、队列监控等功能

  `rabbitMQ`：

  流量控制：服务器过载的情况下，会对生产者速率进行限制，保证服务可靠性

  队列监控：后台可以监控某个队列的所有信息，包括内存，生产者，消费者，速率，磁盘等

  `redis`都不支持，需要自己实现

  

7、消息队列大概过程

​		Broker：简单来说就是消息队列服务器实体。
​		Exchange：消息交换机，它指定消息按什么规则，路由到哪个队列。
​		Queue：消息队列载体，每个消息都会被投入到一个或多个队列。
​		Binding：绑定，它的作用就是把exchange和queue按照路由规则绑定起来。
​		Routing Key：路由关键字，exchange根据这个关键字进行消息投递。
​		`vhost`：虚拟主机，一个broker里可以开设多个`vhost`，用作不同用户的权限分离。
​		producer：消息生产者，就是投递消息的程序。
​		consumer：消息消费者，就是接受消息的程序。
​		channel：消息通道，在客户端的每个TCP连接里，可建立多个channel，每个channel代表一个会		话任务。

​		消息队列的使用过程大概如下：

​		（1）客户端连接到消息队列服务器，打开一个channel。
​		（2）客户端声明一个exchange，并设置相关属性。
​		（3）客户端声明一个queue，并设置相关属性。
​		（4）客户端使用routing key，在exchange和queue之间建立好绑定关系。
​		（5）客户端投递消息到exchange。

###### 6、`mysql`的锁

​	`MyISAM`采用表级锁

   `innodb`支持行级锁和表级锁

​	`BDB`采用页面锁

- 按锁的粒度来划分，可以分为

  - 行锁：锁定粒度最小的一种锁，表示只针对当前操作的行进行加锁，能够大大减少数据库操作的冲突，但加速的开销最大，而且会出现死锁。

    行锁是基于索引的，用不到索引会使用表锁

  - 表锁

  - 页锁

- 共享锁(s锁)和排它锁(x)都是行锁

  共享锁：也叫读锁，可以读读并行。一个线程使用了共享锁后，未有线程使用排他锁，其他线程可以申请共享锁，读取数据，所有事务都不能修改数据，直到所有共享锁释放。 

  select  ---  lock in share mode

  排它锁：也叫死锁，事务A对数据c加上了排他锁后，其他事务不能在对a加任何类型的锁，都会阻塞。有排他锁的事务既能读数据，又能修改数据。其他只能直接select ---不加锁读取数据

  select --- for update

  对于update、insert、delete语句会自动加排它锁

- 按使用方式

  悲观锁：是在操作数据时，认为此操作会发生数据冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作，悲观锁它是数据库自己实现了的，我们直接调用数据库的相关语句就可以了。共享锁和排他锁就是悲观锁的不同体现。使用悲观锁要`set autocommit=0`

  乐观锁：操作数据时，认为数据不会发生冲突，只有在数据提交更新的时候，才会对数据是否冲突进行检测。数据库未提供乐观锁，一般的实现方式就是加版本号。

###### 7、`redis`作为缓存使用

- 为什么要使用缓存

  - 对性能上来说，提高性能。比如从数据库查要几百ms,从缓存中查几ms就可以	

  - 高并发，减轻数据库的压力，`mysql`单机支撑`2000QPS`就开始容易报警了。而缓存并发量轻松10来万每秒。

    因为缓存是走内存的，内存天然支持高并发。

- 缓存的一些不良后果

  缓存数据跟数据库数据不一致

  - 缓存雪崩：所有或者大部分的缓存失效时间相同，那么在同一时间失效时，所有系统的请求都会发送到数据库层，数据库可能无法承受如此大的压力导致系统崩溃

    - 解决办法：

      - 最简单的失效时间交错开，比如在在缓存失效时间设置的时候，从摸个适当的值域中随机选择一个时间作为失效时间。

      - 二级缓存（引入一致性问题）
      
        

  - 缓存击穿：指缓存中没有数据，但数据库中有数据(一般时缓存时间到期)，这时由于并发用户特别多,同时读缓存没读到数据,又同时去数据库去取数据,引起数据库压力瞬间增大。击穿与雪崩的区别即在于击穿时是对于某一特定的热点数据来说，而雪崩是全部数据.(比如明星结婚了)

    - 双重校验（`Dubbo Check`)类似线程安全的懒汉单例模式实现，保证只会有一个线程去访问数据库。
    - 热点数据永不失效，更新时候手动更新

  - 缓存穿透：指的是查询一个一定不存在的数据，缓存中没有该数据，则会去数据库进行查询。从系统层面来看，像是穿透了缓存直接到达数据库，从而称之为缓存穿透，没有缓存层的保护，这种查询一定不存在的数据对系统来说可能是一种危险。如果有人恶意用一定不存在的数据频繁请求系统，请求都会到达数据库可能导致数据库瘫痪从而引起系统故障。

    解决办法：

    - 空值缓存：在第一次查询完不存在的数据后，将该KEY和对应的空值也放入缓存中，设定较短的失效时间，这样就可以应对短时间大量的该key攻击。因为该次的查询未必是攻击者发起。

    - 布隆过滤器：布隆过滤器可以用于检索一个元素是否在一个集合中，它的优点是空间效率和查询时间都远远超过一般的算法。就是用bitmap将所有可能存在的key进行hash方式缓存起来，一定不存在的将通不过过滤器这一层。

  - 缓存满了：内存慢了，溢出

    缓存算法：

    - `LRU` least Recently Used 近期最少使用算法 
    - `LFU` least Frequently Used 最不经常使用算法
    - FIFO first in first out  先进先出

    我们公司一般缓存更新的化就是`lru`做兜底，然后基本上主动更新为主。而且一般设置过期时间的话也只是短信验证码之类的小部分应用场景。

    使用以上策略要设计到一个参数：`maxmemory_policy`最大内存策略 

- `redis`持久化

  - `RDB`  在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot)，可以设置比如每小时备份一次`RDB`文件,然后开一个子进程去快照持久化，是一个全量的数据文件，恢复速度块。

  - `AOF`文件是只记录追加操作的日志文件，有序的保存了对数据库执行的所有写入操作,可以设置`fsync`策略,比如没秒钟一次`fsync`,或者每次执行写入命令时`fsync`,或者无`fysnc`

  - 优缺点对比：

    - `RDB`文件更小，因为时紧凑型数据,恢复更快，因为数据的快照，基本就是数据的复制。

    - `AOF`优点数据保证，设置`fsync`,一般默认时`everysec`,这样即使服务器死掉了，也就丢失一秒的数据。

      自动缩小也叫重写，当`AOF`文件到达一定程度后，后台会自动的执行`AOF`重写fork一个子进程，对当前内存中的数据进行遍历，转化成相应的一系列`redis`操作指令,并序列化到一个新的`AOF`日志中，在序列化期间新收到的操作指令添加到新的`AOF`文件中，添加完成后替换旧的`AOF`文件，删除旧的。

      `redis`将操作指令追加到`AOF`文件这个过程，并不时直接写到`AOF`文件中，而是先写到操作系统的内存缓存中，而是先写到操作系统的内存缓存中，这个内存缓存是由操作系统内核分配的，然后操作系统内核会异步地内存缓存中的`redis`指令刷到`AOF`文件中。

      

  - `redis-4.x`支持混合持久化

    `RDB`文件的内容和`AOF`日志，这里的`AOF`不再是全量的日志，而是自持久化开始到持久化结束这段时间发生的增量`AOF`日志。

  ```
  ######################### 通用 #########################
  
  # 持久化文件(包括RDB文件和AOF文件)的存储目录，默认.
  
  dir dir /home/hadoop/data/redis/6379
  ######################### RDB #########################
  
  # RDB文件的文件名称，默认dump.rdb
  dbfilename dump.rdb
  # 生成RDB文件的策略，默认为以下3种，意思是：
  # 每隔60s(1min)，如果有超过10000个key发生了变化，就写一份新的RDB文件
  # 每隔300s(5min)，如果有超过10个key发生了变化，就写一份新的RDB文件
  # 每隔900s(15min)，如果有超过1个key发生了变化，就写一份新的RDB文件
  # 配置多种策略可以同时生效，无论满足哪一种条件都会写一份新的RDB文件
  save 900 1
  save 300 10
  save 60 10000
  
  # 是否开启RDB文件压缩，该功能可以节约磁盘空间，默认为yes
  rdbcompression yes
  
  # 在写入文件和读取文件时是否开启rdb文件检查，检查是否有无损坏
  # 如果在启动时检查发现文件损坏，则停止启动，默认yes
  rdbchecksum yes
  
  ######################### AOF #########################
  
  # 是否开启AOF机制，默认为no
  appendonly yes
  
  # AOF文件的名称，默认为appendonly.aof
  appendfilename "appendonly.aof"
  
  # fsync的策略，默认为everysec
  # everysec：每秒fsync一次
  # no：redis不主动fsync，完全交由操作系统决定
  # always：1条指令fsync一次
  appendfsync everysec
  
  # AOF文件rewrite策略
  # 当上一次重写后的AOF文件的增长比例达到100%
  # 比如上一次重写AOF文件后，新文件大小为128M
  # 当新文件再次增长了100%，达到了256M
  # 并且增长了100%后的文件的大小大于64M，那么开始重写AOF文件
  auto-aof-rewrite-percentage 100
  auto-aof-rewrite-min-size 64mb
  
  # 是否加载破损的AOF文件，默认为yes，如果设置为no
  # 那么redis启动时如果发现AOF文件破损，就会报错并且拒绝启动redis服务。
  aof-load-truncated yes
  ######################### 混合持久化 #########################
  # 是否开启混合持久化机制，默认为no
  aof-use-rdb-preamble no
  ```

  `redis`过期时间的设置

`redis`商品详情过期时间我们设置的一天，当一个商品的详情页面一天没有人访问，缓存 就过期。

如果有人访问，就更新过期时间。

解决`redis`和数据库数据不一致

- 给缓存设置过期时间，是保证最终一致性的解决方案。我们可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力即可
- 延迟双删  更新时，先删除缓存，更新数据库，延迟`500ms`，再删除缓存

8、`http`缓存请求响应头

​	`http`缓存主要针对`css`、`js`,图片等更新频率不大的静态文件。是通过meta标签，但代理缓存基本不访问文档内容，所以尽量在`Http头`中设置

- Cache-Control 请求/响应头，缓存控制字段，要不要缓存也是它说了算。
  - no-store:所有内容都不缓存
  - no-cache :缓存，但是浏览器使用缓存前，都会请求服务器判断缓存资源是否是最新
  - max-age =x(单位秒)  请求缓存的x秒不再发起请求，属于`http1.1`属性，与下方Expires(`http1.0`)类似，但优先级要比Expire高。
  - `s-maxage`=x(单位秒) 代理服务器请求源站缓存后的x秒不再发起请求，只对`CDN`缓存有效
  - public客户端和代理服务器(`CDN`)都可以缓存
  - private只有客户端可以缓存
- Expires 响应头，代表过期时间，由服务器返回提供。GMT格式日期，是`http1.0`的属性,与max-age共存的情况下，优先级低。
- Last-Modified 响应头，资源最新修改时间，由服务器告诉浏览器
- if-Modified-since 请求头，资源最新修改时间，由浏览器告诉服务器，服务器拿它和last-modified进行对比
- `Etag` 响应头,资源标识，由服务器告诉浏览器
- if-None-Match 请求头，缓存资源标识，由浏览器告诉服务器,和`Etag`对比

- 我们为什么使用`Http`缓存

  客户端每次都要请求服务器，浪费流量，带宽

  用户基数大时，服务器存在较大压力

- `http`缓存方案

  让服务器与浏览器在过期时间max-age+Last-Modified的基础上，再增加一个文件内容唯一对比标记`Etag`与If-None-Match。

  通过不缓存`html`页面,为静态文件添加`MD5`或者hash标识,这样每次`html`加载渲染感知文件变化，反正文件没变还是使用本地缓存，文件名都变了说明修改过，重新请求缓存就好了。

  强缓存（过期时间）和弱缓存（协商缓存，last-modified和`etag`）

###### 9、缓存分类

- 数据库缓存 
  - 数据库的缓存一般由数据库提供，可以对表建立高速缓存。数据库中，用户可能多次执行相同的查询语句，为了提高查询效率，数据库会在内存划分一个专门的区域，用来存放用户最近执行的查询，这块区域就是缓存。如`mysql`的query_cache
  - “空间换时间”，比如建一个表来存储另外一个表某个类型的数据的总条数，在每次更新数据的时候同事更新 数据表和统计条数的表。在需要获取某个类型的数据的条数的时候，就不需要select count去查询，直接查询统计表就可以了，这样可以提高查询的速度和数据库的性能

- 应用层缓存(与开发人员关系最大)
  - 缓存数据库的查询结果,减少数据的压力。这个在大型网站是必须做的。
  - 缓存磁盘文件的数据。比如常用的数据可以放到内存，不用每次都去读取磁盘，特别是密集计算的程序，比如中文分词的词库。
  - 缓存某个耗时的计算操作，比如数据统计

- 前端缓存，主要还是针对静态文件类型，比如图片，`css,js,html`等静态文件
  
- 请求更快：通过将内容缓存在距离最近的缓存服务器（如`CDN`），在不影响网站交互的前提下可以大大加快网站加载速度。
  
- 客户端缓存(浏览器缓存)：

  客户端缓存依赖于浏览器的实现，目前一般的浏览器都实现了基于`http`都信息来缓存相应的文件。浏览器端的缓存，可以让用户请求一次之后，下一次不在从服务器端请求数据，直接从本地缓存读取，可以减轻服务器负担也可以加快用户的访问速度。
  浏览器缓存分为强缓存和协商缓存：

  - 强缓存：浏览器在加载资源时，先根据这个资源的一些`http header`判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如某个`css`文件，如果浏览器在加载它所在的网页时，这个`css`文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个`css`，连请求都不会发送到网页所在服务器；
  - 协商缓存：当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些`http header`验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回（304），但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源；若未命中请求，则将资源返回客户端，并更新本地缓存数据（200）。

  强缓存与协商缓存区别：强缓存不发请求到服务器，协商缓存会发请求到服务器。

  HTTP头信息控制缓存是通过Expires（强缓存）、Cache-control（强缓存）、Last-Modified/If-Modified-Since（协商缓存）、`Etag`/If-None-Match（协商缓存）实现，下面详细介绍。

10、`mysql`数据库

数据库就是安装找数据结构来组织、存储和管理数据的仓库

`RDBMS`即关系数据库管理系统

索引：使用索引可以快速访问数据表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构，类似于书籍的目录

`mysql`查询语句顺序 select –>where –> group by–> having–>order by 



11、`mongoDB`

`MongoDB`提供了一个面向文档存储，基本思路是将原来的“行”的概念换成了“文档”模型，一条记录可以表示非常复杂的层次关系。

- 支持丰富的查询表达式，查询指令是`json`形式的标记，可以轻易查询文档中嵌套的对象和列表
- 非常容易扩展，扩展集群后还可以实现集群中数据的负载均衡
- 方便管理，管理集群只需知道有哪个新增的节点即可，自动继承和配置新节点。
- 它里面是 database > collection > document >field >index ,`mongodb`不支持表关联