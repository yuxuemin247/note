[TOC]

##### 视图



```python
视图是由一张表或多张表的查询结果构成的一张虚拟表，视图的数据依赖于原来表中的数据，如果原来表的数据发生了改变，那么视图的数据也会改变。
将复杂常用的查询结果保留下来重复使用 | 将一张大表拆分成多张小表

语法：
create [or replace] view 视图名[(查询字段别名们)] as 查询语句
create view new_emp as (select * from emp);

注：
1.查询字段别名们 要与 查询语句的查询字段对应
2.create or replace: 操作视图没有则创建、有则替换
create or replace view new_emp(id,姓名,工资) as (select id,name,salary from emp where dep_id = 2);

视图的修改：alter 等价于 create or replace, 且语法一致
alter view new_emp(id,姓名,工资) as (select id,name,salary from emp where dep_id = 1);

视图中记录的操作：等价于普通表，完成增删改查
update new_emp set 姓名='san' where id = 3;
delete from new_emp where id = 3;
insert into new_emp(id, 姓名, 工资) values (10, "Bob", 10000);
# 操作的是实体表, 虚拟表要重新创建才能拿到最新数据。一般不直接更新视图中的数据，视图只做查询。

视图的删除:
drop view 视图名;

总结: 虚拟表作用 -- 查询
重用SQL语句，将高度复杂的查询包装在视图表中，直接访问该视图即可取出需要的数据；也可以将视图视为数据表进行连接查询.
因为视图不包含数据，所以每次使用视图时，都必须执行查询以获得数据，如果你使用了连接查询、嵌套查询创建了较为复杂的视图，你可能会发现查询性能下降得很厉害
```

- 视图使用建议

  ```
  视图命名建议统一前缀，比如以v或view开头，便于识别。
  SQL SECURITY使用默认的DEFINER，表示已视图定义者的权限去查询视图。
  视图不要关联太多的表，造成数据冗余。
  查询视图时要附带条件，不建议每次都查询出所有数据。
  视图迁移要注意在新环境有该视图的定义者用户。
  不要直接更新视图中的数据，视图只作查询
  视图可以嵌套，可以利用从其他视图中检索的数据来构造一个新的视图。
  ```

- 缺点
  - 视图无法使用索引，也不会激发触发器。

##### 存储过程

- 存储过程优点

  - 降低网络的通讯量，如果只是简单的`SQL`语句的话存储过程和普通`SQL`没有太大区别，但随着`SQL`量越来越大甚至打到上百行时，其优越性明显体现
- 提高执行效率。`SQL`是先编译再执行的,而存储过程是预编译在服务器中的，当执行的时候跳过编译的环节效率自然会提高
  - 可维护性高。可实现模块化的程序设计，存储过程可以多次调用，提供统一的数据库访问接口，更新存储过程通常比更新，测试，重新部署需要较少的时间和精力 
- 调用存储过程并没有暴露数据表的细节
- 缺点
- 过度使用存储过程，将大量复杂的运算放到存储过程中，也会导致占用数据库服务器的CPU资源，造成数据库服务器承受巨大的压力，因此，一般会将复杂的运算和处理交给应用服务器，因为很容易部署多台应用服务器来分摊这些压力。

```python
what：用于完成指定功能的sql语句块，类似于Python中的函数，存储过程是事先编译好存储在数据库中的一组SQL的集合。
why：将能指定功能的sql语句块建立成存储过程，不仅将sql语句逻辑化了，更是功能化了，那我们要完成相同的事，只需要重复使用建立的存储过程，不就需要再重复书写sql语句了

语法：
delimiter //
create procedure 存储过程名(
	输入输出类型1 参数名1 参数类型1(宽度), 
	... ,
	输入输出类型n 参数名n 参数类型n(宽度)
)
begin
sql语句块
end //
delimiter ;
注：
1.输入输出类型：in | out | inout
2.call 存储过程名(实参们)来调用存储过程

案例：
set @res = null; # 定义空值变量, 用来接收存储过程的执行结果
delimiter //
create procedure user_info(
    in b int,
    in l int, 
    out res char(20))
begin
select * from emp limit b, l;
set res = 'success';
end //
delimiter ;

call user_info(2, 3, @res); # 调用存储过程, 传入相应的实参
select @res; # 查看存储过程的执行结果

变量的使用：
1.赋值变量：set @变量名 = 变量值
2.使用变量：@变量名 | select @变量名
3.删除变量：set @变量名 = null

三种开发方式：
1. 业务逻辑 + 存储过程：高执行与开发效率，低耦合 | 不易移植，人员成本高
2. 业务逻辑 + 原生sql：人员成本低 | 开发难度大
3. 业务逻辑 + ORM：高开发效率，对象化操作数据库，可移植 | 性能消耗加大，多表联查、复杂条件会复制化ORM

存储过程的操作：
1.查看
select routine_name, routine_type from information_schema.routines where routine_schema='数据库名';

eg: select routine_name, routine_type from information_schema.routines where routine_schema='db2';

2.删除
drop procedure [if exists] 数据库名.存储过程名
'''
```

```mysql
delimiter //
create procedure send_money( out p_return_code char(20) )
begin 
	# 异常处理
    declare exit handler for sqlexception 
    begin 
        # error 
        set p_return_code = '错误异常'; 
        rollback; 
    end; 
	# exit 也可以换成continue 表示发送异常时继续执行
    declare exit handler for sqlwarning 
    begin 
        # warning 
        set p_return_code = '警告异常'; 
        rollback; 
    end; 

    start transaction;
	update account set money = money - 1000 where id = 1;
	update account set money = moneys + 1000 where id = 2; # moneys字段导致异常
    commit; 
    # success 
    set p_return_code = '转账成功'; # 代表执行成功
end //
delimiter ;

# 在mysql中调用存储过程
set @res=null;
call send_money(@res);
select @res;
```

##### 流程控制

- if语句的使用

```python
第一种 if:
"""
if 条件 then
语句;
end if;
"""
第二种 if elseif
"""
if 条件  then
语句1;
elseif 条件 then
语句2;
else 语句3;
end if;
"""
```

案例:编写过程 实现 输入一个整数type  范围 1 - 2 输出  type=1 or type=2 or type=other;

```mysql
delimiter //
create procedure showType(in type int,out result char(20))
begin
if type = 1 then 
set result = "type = 1";
elseif type = 2 then 
set result = "type = 2";
else 
set result = "type = other";
end if;
end //
delimiter ;

set @res=null;
call showType(100, @res);
select @res;
```

- CASE 语句

 大体意思与Swtich一样的  你给我一个值 我对它进行选择 然后执行匹配上的语句
语法:

```a
create procedure caseTest(in type int)
begin
CASE type 
when 1  then select "type = 1";
when 2  then select "type = 2";
else select "type = other";
end case;
end
```

- 定义变量 

declare  变量名 类型 default 值;
例如: declare i int default 0;

- WHILE循环

```a
循环输出10次hello mysql
create procedure showHello()
begin 
declare i int default 0;
while  i < 10 do
select "hello mysql";
set i  = i + 1;
end while;
end
```

- LOOP循环的

 没有条件 需要自己定义结束语句
语法:

```a
输出十次hello mysql;
create procedure showloop()
begin 
declare i int default 0;
aloop: LOOP
select "hello loop";
set i = i + 1;
if i > 9 then leave aloop;
end if;
end LOOP aloop;
end
```

- REPEAT循环

```
#类似do while
#输出10次hello repeat
create procedure showRepeat()
begin
declare i int default 0;
repeat
select "hello repeat";
set i = i + 1;
until i > 9
end repeat;
end

#输出0-100之间的奇数
create procedure showjishu()
begin
declare i int default 0;
aloop: loop
set i = i + 1;
if i >= 101 then leave aloop; end if;
if i % 2 = 0 then iterate aloop; end if;
select i;
end loop aloop;
end
```

##### 触发器

- ```
  what：在表发生数据更新时，会自动触发的功能称之为触发器
  当一个表在发生数据更新时，需要去完成一些操作，可以为具体数据更新的方式添加触发器
  
  语法：
  delimiter //
  create trigger 触发器名 before|after insert|update|delete on 表名 for each row
  begin 
      需要触发执行的sql代码们
  end //
  delimiter ;
  
  # 触发器名: t1_before_insert_tri
  
  注：delimiter是用来修改sql的语句结束标识符
  
  删除触发器：drop trigger 触发器名;
  ```

- ```
  # cmd表
  create table cmd (
      id int primary key auto_increment,
      user char(32),
      priv char(10),
      cmd char (64),
      sub_time datetime, # 提交时间
      success enum ('yes', 'no') # 0代表执行失败
  );
  # 错误日志表
  create table errlog (
      id int primary key auto_increment,
      err_cmd char(64),
      err_time datetime
  );
  # 创建触发器
  delimiter //
  create trigger trigger1 after insert on cmd for each row
  begin
  # new就是cmd当前插入的那条记录(对象)
  if new.success = "no" then
  	insert into errlog values(null, new.cmd, new.sub_time);
  end if;
  end //
  delimiter ;
  
  # 往表cmd中插入记录，触发触发器，根据IF的条件决定是否插入错误日志
  insert into cmd(user, priv, cmd, sub_time, success) values
      ('egon', '0765', 'ls -l /etc', now(), 'yes'),
      ('jerry', '0852', 'cat /etc/passwd', now(), 'no'),
      ('kevin', '0867', 'useradd xxx', now(), 'no'),
      ('owen', '0912', 'ps aux', now(), 'yes');
  # 查看cmd数据信息
  select * from cmd;
  # 查看错误日志表中的记录是否有自动插入
  select * from errlog;
  ```