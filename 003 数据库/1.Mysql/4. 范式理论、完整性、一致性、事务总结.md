[TOC]

##### 一、范式理论

​    范式可以避免数据冗余，减少数据库的空间，减轻维护数据完整性的麻烦。 

- 第一范式：强调列要具有原子性，不可拆分性(最小)
- 第二范式：记录的唯一性约束
- 第三范式：强调属性冗余性的约束，不能由其他列计算得来
  - 很多时候也会违反

##### 二、数据完整性

- 实体完整性 - 每个实体都是独一无二的
  - 主键（primary key） / 唯一约束 / 唯一索引（unique）
- 引用完整性（参照完整性）- 关系中不允许引用不存在的实体
  - 外键（foreign key）
- 域完整性 - 数据是有效的
  - 数据类型及长度约束
  - 非空约束（not null）
  - 默认值约束（default）
  - 检查约束(check)
    - 在`MySQL`数据库中，检查约束并不起作用

##### 三、数据一致性

###### 事务

- `MYSQL`是以个服务器/客户端(CS)架构的软件，对于同一个服务器来说,可以有若干个客户端与之连接，每个客户端与服务器连接上后，就可以称之为一个会话。

- 事务： 事务中可能包含一个或多个`sql`语句,一系列对数据库进行读/写的操作，这些操作要么全都成功，要么全都失败

- 事务的ACID特性

  - 原子性：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行

    - 实现原理(`innoDB`还提供了两种日志,redo log(重做日志)和undo log(回滚日志))

    - 实现原子性的关键(undo log日志)，是当事务回滚时能够撤销已经成功执行的`SQL`语句

      当数据修改时，会生成对应的undo log,如果事务执行失败或者调用了rollback,导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。(反向执行)

      

  - 一致性：事务前后的数据完整性应该保持一致(数据库的完整性：如果数据库在某一时间点下，所有的数据都符合所有的约束，则称数据库为完整性的状态)

    -  致性是事务追求的最终目标：原子性、持久性和隔离性，都是为了保证数据库状态的一致性。 

    -  除了数据库层面的保障，一致性的实现也需要应用层面进行保障 

      

  - 隔离性：多个事务并发执行时，一个事务内部的执行不应影响其他事务的执行

    - `InnoDB`通过锁机制和`MVCC`来保证隔离性
      - 行锁：只需要锁定需要操作的数据，并发性能好。但当要锁定的数据行较多时，由于加锁本身需要消耗资源(获得锁、检查锁、释放锁等都需要消耗资源)，不如表锁可以节省大量资源
      - 表锁：并发来讲，并发性能较差
    - `MVCC` `Muti-Version concurrency Control` 多版本的并发控制协议
      - 特点： 在同一时刻，不同的事务读取到的数据可能是不同的(即多版本) 。事务A和事务C可以读取到不同版本的数据 

    

  - 持久性：持久性是指一个事物一旦被提交，它对数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响

    - 实现原理(redo log日志)
    - `InnoDB`作为`MySQL`的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘IO，效率会很低。为此，`InnoDB`提供了缓存(Buffer Pool)，Buffer Pool中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲：当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool；当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中（这一过程称为刷脏）
    - 因为`innodb`提供了缓存(Buffer Pool)。数据修改时，所有修改先写入redo log(Write-ahead logging 预写式日志)，在更新到Buffer Pool，保证了数据不会因宕机而丢失，从而满足了持久性要求 
    - 既然redo log也需要将日志写入磁盘，为什么它比直接将Buffer Pool中修改的数据写入磁盘（刷脏）块呢？
      - 刷脏是随机IO，因为每次修改的数据位置随机(要找)，但写redo log是追加操作，属于顺序IO
      - 刷脏是以数据(Page)为单位的，`MYSQL`默认页大小是`16KB`,一个Page上一个小修改都要整页写入，而redo log只包含真正需要写入的部分，无效IO大大减少。

- 事务操作

  ```
  #开启事务环境
  start transaction  或者 begin
  #提交事务
  commit
  #或者回滚事务
  rollback
  ```

- 事务的隔离级别

  ```
  Serializable     --数据库运行在串行化实现,所有问题都没有,就是性能低
  
  修改隔离级c别:
  select @@tx_isolation;--查询当前级别(mysql 5.7版本)
  select @@global.transaction_isolation,@@transaction_isolation; --查询当前级别(mysql 8.0版本)
  set[session|global] transaction isolation level ....;修改级别
  实例:
  set global transaction isolation level Repeatable read;
  注：修改后重新连接服务器生效
  '''
  mysql默认是RR 可重复读
  ```
  
  - 脏读：A事务可以读到事务B未提交的数据
  - 不可重复读: 在事务A中先后两次读取同一个数据，两次读取的结果不一样。
    -  脏读与不可重复读的区别在于：前者读到的是其他事务未提交的数据，后者读到的是其他事务已提交的数据 
  - 幻读：在事务A中按照某个条件查询数据库，两次查询的条数不同，这种现象称为幻读。
    -  不可重复读与幻读的区别可以通俗的理解为：前者是数据变了，后者是数据的行数变了 

- `MVCC`

  ```
  版本链：对于使用`InnoDB`存储引擎的表来说，它的聚簇索引记录种都包含了两个必要的隐藏列(`trx_id`、roll_pointer)
  
  trx_id:每次对某条聚簇索引记录进行改动时，都会把对应的事务id赋值`trx_id`隐藏列
  roll_pointer:每次对某条聚簇索引记录进行改动时，都会把旧的版本写入`undo`日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。
  每条记录更新后，都会将旧值放到一条undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被roll_pointer属性连接称成一个链表，称为版本链，版本链的头节点就是当前记录最新的值，另外每个版本中还包含生成该版本的事务id
  
  ReadView中主要包含当前系统中还有哪些活跃的读写事务,把它们的事务id放到一个列表中，把这个列表称为m_ids。
  
  在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：
  
  - 如果被访问版本的trx_id属性值小于m_ids列表中最小的事务id,表明生成该版本的事务在生成ReadView前已经提交，所以该版本可以被当前事务访问。
  
  - 如果被访问版本的trx_id属性值大于m_ids列表中最大的事务id,表名生成该版本的事务在生成ReadView后才生成，所以该版本不可以被当前事务访问。
  - 如果被访问版本的trx_id属性值在m_ids列表中最大的事务id和最小事务id之间，那就需要判断一下trx_id属性值是不是在m_ids列表中，如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。
  ```

  