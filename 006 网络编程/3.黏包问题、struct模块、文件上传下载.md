[TOC]

# 粘包问题

数据与数据之间没有明确的分界线，导致不能正确读取数据

**接收方不知道发送方一次到底发送了多少数据**

**TCP可以保证数据的完整性**（会粘包） UDP不会粘包，因其是基于数据表发送数据

**TCP**：流式协议

有一套校验规则来保证数据的完整性，会将超过TCP包最大长度的数据拆分为多个TCP包，并在传输数据时为每一个TCP数据包指定一个顺序号，接收方在收到TCP数据包后按照顺序将数据包进行重组。重组后的数据全都是二进制数据，且每次收到的二进制数据之间没有明显的分界

存在问题：

1.当单个数据包较小时接收方可能一次性读取了多个包的数据

2.当整体数据较大时接收方可能一次仅读取了一个包的一部分内容

3.另外TCP协议为了提高效率，增加了一种优化机制，会将数据较小且发送间隔较短的数据合并发送，该机制也会导致发送方将两个数据包黏在一起发送

**UDP**：数据报协议

收发数据基于数据包，即一个包一个包的发送，包与包之间有着明确的分界，到达对方操作系统缓冲区后也是一个一个独立的数据包，接收方从操作系统缓冲区中将数据包拷贝到应用程序

存在的问题：

1.发送方发送的数据长度每个操作系统会有不同的限制，数据超过限制则无法发送

2.接收方接收数据时如果应用程序提供的缓存容量小于数据包的长度将造成数据丢失，而缓冲区大小不可能无限大

**黏包问题的解决思路**：

接收方需要先获取数据的长度

需要发送方先发送数据的长度给接收方

接收方收到长度之后，按照数据长度来获取数据

**粘包问题的解决方案**：

**发送方先发送数据长度**，接收方接收长度（长度必须是固定字节）

自定义报头，不仅可以传输数据长度，还能添加任意额外信息

**报头格式**建议使用 json，可以跨平台

## 自定义报头解决粘包

发送方：

- 将所有的额外信息打包到头部数据
- 发送头部数据
- 发送真实数据

接收端：

- 接收固定长度的头部长度数据
- 根据长度数据获取头部数据
- 根据头部数据获取真实数据

服务器

```python
import  socket
import subprocess
import struct
import datetime
import json

server = socket.socket()
server.bind(("127.0.0.1",8888))
server.listen()

# 要求  不仅返回命令的结果 还要返回执行命令的时间  执行时间:2018/12/26

while True:
    client,addr = server.accept()
    while True:
        try:
            # 接收命令
            cmd = client.recv(1024).decode("utf-8")
            p = subprocess.Popen(cmd,shell=True,stdout=-1,stderr=-1)
            # data与err_data 都是采用的系统编码 windows是GBK
            data = p.stdout.read()
            err_data = p.stderr.read()

            print("数据长度:%s" % (len(data)   + len(err_data)))
            # 计算真实数据长度
            length = len(data)   + len(err_data)


            # 在发送数据之前发送额外的信息
            #t = "{执行时间:%s 真实数据长度:%s" % (datetime.datetime.now(),length)
            # 把要发送的数据先存到字典中
            t = {}
            t["time"] = str(datetime.datetime.now())
            t["size"] = length
            t["filename"] = "a.mp4"


            t_json = json.dumps(t) # 得到json格式字符串
            t_data = t_json.encode("utf-8") # 将json转成了字节
            t_length = struct.pack("i",len(t_data))



            # 1.先发送额外信息的长度
            client.send(t_length)
            # 2.发送额外信息
            client.send(t_data)

            # 3.发送真实数据
            client.send(data)
            client.send(err_data)
        except ConnectionResetError:
            client.close()
            print("连接中断......")
            break

#  1.发送了真实数据长度   2.发送了额外信息长度  3.发送额外信息  4.真实数据
```

客户端

```python

import socket
import struct
import socket
import json

c = socket.socket()
c.connect(("127.0.0.1",8888))
while True:
    cmd = input(">>:")
    if not cmd:
        print("命令不能为空")
        continue
    c.send(cmd.encode("utf-8"))

    # 1.接收的是额外信息的长度
    length = c.recv(4)
    len_data = struct.unpack("i",length)[0] # 转换为整型

    # 2.接收额外信息
    t_data = c.recv(len_data)
    print(t_data.decode("utf-8"))

    json_dic = json.loads(t_data.decode("utf-8"))
    print("执行时间:%s" % json_dic["time"])

    data_size = json_dic["size"] # 得到数据长度


    # 3.接收真实数据
    all_data = b"" # 存储已接收数据
    rcv_size = 0 # 已接收长度
    # 接收真实数据
    # 循环接收 直到 接收到的长度等于总长度
    while  rcv_size < data_size:
        data = c.recv(1024)
        rcv_size += len(data)
        all_data += data

    print("接收长度%s" % rcv_size)
    print(all_data.decode("gbk"))
```



# struct模块

**将 python 中的数据类型转换成 bytes**

```python
num = 1024

import struct

# 该函数 将一个python的数据转成bytes   第一个参数通常是i 其能转换的数据范围是c语言的int范围
# 如果int不够 那就用q  表示long long 型
res = struct.pack("i",num)
print(res)
print(len(res))


# 从字节转回整型
res2 = struct.unpack("i",res)
print(res2[0])
```



# 文件上传下载

1.采用TCP，保证数据的完整性

2.只能传输bytes类型

3.上传思路：

自定义报头，发送文件名，文件大小，md5值，读取文件数据，发送给对方

上传：

客户端：

```python
import socket
import os
import json
import struct
c = socket.socket()
c.connect(("127.0.0.1",9090))

filepath=  r"文件地址"
f = open(filepath,mode="rb")

# 在发送数据前先发送报头
head = {"size":os.path.getsize(filepath),"filename":"回顾.mp4"}
json_data = json.dumps(head).encode("utf-8")

json_len = struct.pack("i",len(json_data))
c.send(json_len) # 发长度
c.send(json_data) # 发报头

# 发数据
while True:
    data = f.read(1024)
    if not data:
        break
    # 发送给服务器
    c.send(data)

print("上传完成...")
```

服务器：

```python
import  socket
import  struct
import  json
server = socket.socket()
server.bind(("127.0.0.1",9090))
server.listen()
client,addr = server.accept()

f =  open("接收到的文件",mode="wb")

head_len = client.recv(4)
json_len = struct.unpack("i",head_len)[0]

json_str = client.recv(json_len).decode("utf-8")
head = json.loads(json_str)
print(head)


recv_size = 0
while recv_size < head["size"]:
    data = client.recv(1024)
    f.write(data)
    recv_size += len(data)

print("接收完成...")
```



