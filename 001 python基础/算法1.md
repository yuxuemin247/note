##### 1、排序

```python

 #快速排序 时间复杂度 O(nlogn)，空间复杂度 O(1)
def quick_start(li,left,right):
    if left < right:
        mid=partition(li,left,right)
        quick_start(li,left,mid-1)
        quick_start(li,mid+1,right)

def partition(li,left,right):
    temp = li [left]
    while left <right :
        while left <right and li[right] > temp:
            right = right -1
        li[left] = li [right]

        while left < right and li[left] < temp:
            left =left +1
        li[right] = li[left]
    li[left] = temp
    return left

#冒泡排序 时间复杂度o(n**2) ,空间复杂度 o(1)
def sort1(li):
    for i in range(len(li)-1):
        for j in range(len(li)-i-1):
            if li[j] >li[j+1]:
                li[j],li[j+1] = li[j+1],li[j]
                
#选择排序  时间复杂度o(n**2) ,空间复杂度 o(1)
def selctor_sort(li):
    for i in range(len(li)-1):
        min_index = i
        for j in range(i+1,len(li)):
            if li[j] < li[min_index]:
            	min_index = j
        li[i],li[min_index] = li[min_index],li[i]
        

#插入排序 时间复杂度：O(n**2) ,空间复杂度： O(1)
def insert_sort(li):
    for i in range(1,len(li)):
        temp =li [i]
        j = i-1
        while j >= 0 and  temp < li[j]:
            li[j+1] =li[j]
            j=j-1
        li[j+1] = temp
```

##### 2、二分查找

```python
二分查找
def banery_search(li,val):
    left = 0
    right= len(li)
    while left <= right :          #这必须要有等号，要不下标0的元素取不到
        mid = (left+right)//2
        if val < li[mid]:
            right =mid -1
        elif val >li[mid]:
            left =mid +1
        elif val == li[mid]:
            return mid
    return -1
```

###### 3、将字符串压缩  `aaaabbbccaa`  >>>`a4b3c2a2`  

```
def compress_text(text) :
	res,letter,num = '','',0
	for letter_new in text:
		if letter_new == letter:
			num += 1
		else:
			res += letter+str(num)  if num else ''
            letter,num = new_letter,1
    #不小于就没必要压缩了
    return res if len(res) <len(text) else text 
#这又个bug最后一个字母的位数不显示，不行就最后随便拼接一个
```

4、如何判定链表是否有环，怎么找出环起点

```
class LNode:
    def __init__(self, val):
        self.val = val
        self.next = None


# 判断链表是否有环,并返回入环节点
# 判断是否有环，用快指针和慢指针，当两个指针相遇时，说明有环
def exit_loop(LList):
    p1 = p2 = LList
    # 当链表为空或者只有一个节点时，跳出循环，返回False
    while p2 and p2.next:
        p1 = p1.next
        p2 = p2.next.next
        if p1 == p2:
            return True
    return False

# 如果链表有环，返回入环节点
# 当确定有环后，慢指针重新回到头节点，快指针停留在相遇处，然后两个指针每次移动1个节点，最终他们在入环节点处相遇
def find_entry_of_loop(pHead):
    if not pHead:
        return None
    slow = pHead
    fast = pHead

    while slow.next and fast.next.next:
        slow = slow.next
        fast = fast.next.next
        # 当两个指针相遇时，说明有环，循环结束
        if fast == slow:
            break

    # 快指针停留在相遇处，慢指针回到起点
    if not fast or not fast.next:
        return None
    slow = pHead

    # 两个指针每次向前移动1，当再次相遇时，相遇点即为入环节点
    while slow != fast:
        slow = slow.next
        fast = fast.next
    return slow


if __name__ == "__main__":
    LList = LNode(0)
    p1 = LNode(1)
    p2 = LNode(2)
    p3 = LNode(3)
    p4 = LNode(4)
    p5 = LNode(5)
    LList.next = p1
    p1.next = p2
    p2.next = p3
    p3.next = p4
    p4.next = p5
    p5.next = p2
    print (exit_loop(LList))
    print (find_entry_of_loop(LList).val)
```

