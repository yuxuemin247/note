##### 一、什么是垃圾回收机制

- 垃圾回收机制(简称是GC)是python解释器自带的一种机制,专门用来回收不可用的变量值所占用的空间

##### 二、为什么要用垃圾回收机制

- 程序在运行过程中会申请大量的内存空间,而对于一些无用的内存空间如果不及时清理的会导自级内存使用殆尽(内存溢出),导致程序崩溃,因此管理内存是一件重要且复杂的事情.python自带的垃圾回收机制帮程序员从繁杂的内存管理中解放出来.

##### 三、垃圾回收机制原理

```
Python中，主要依靠gc(garbage collecto)模块的引用计数技术(reference counting)来跟踪和回收垃圾,在引用计数的基础上，通过“标记 -清除”(mark and sweep)解决容器对象可能产生的循环引用问题,并且通过“分代回收”（ generation collection ）以空间换时间的方法提高垃圾回收效率。
```

- 1 引用计数

  `Pyobject `是每个对象必有的内容，其中`ob_refcnt` 就是引用计数。当一个对象有新的引用时，它的`ob_refcnt `就会增加，当引用它的对象删除，它的`ob_refcnt`就会减少，引用技术为0，该对象生命就结束了。

  优点：简单，时效性

  缺点: 维护引用计数消耗资源,

  ​		 变量值被关联次数的增加或减少，都会引发引用计数机制的执行，这存在明显的效率问题

  ​		 容器对象的循环引用

- 2 标记-清除机制

   基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把没有被标记的对象释放

   ```python
   #循环引用
   l1 = [1, ]
   l2 = ['a', ]
   l1.append(l2)
   l2.append(l1)
   print(l1)
   print(l2)
   del l1
   del l2
   # [1, ] | ['a', ] 引用计数均为1, 彼此互相引用
   ```

- 3、 分代技术

  - 核心思想:在多次扫描的情况下，都没有被回收的变量，`gc`机制就会认为，该变量是常用变量，`gc`对其扫描的频率会降低

  分代回收：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就是一个"代"，垃圾收集频率随着“代”的存活时间的增大而减少。存活时间通常利用几次垃圾回收来度量。

  python默认定义二零三代对象集合，索引数越大，对象存活时间越长。

  当某些内存块 M 经过了 几次垃圾收集的清洗之后还存活时，我们就将内存块 M 划
  到一个集合 A 中去，而新分配的内存都划分到集合 B 中去。当垃圾收集开始工作时，
  大多数情况都只对集合 B 进行垃圾回收，而对集合 A 进行垃圾回收要隔相当长一段
  时间后才进行，这就使得垃圾收集机制需要处理的内存少了，效率自然就提高了。
  在这个过程中，集合 B 中的某些内存块由于存活时间长而会被转移到集合 A 中，当
  然，集合 A 中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代的机制而被
  延迟。

- python的内存管理

  ​		引用计数、垃圾回收和内存池

  ​		大内存使用`malloc`进行分配 （`256K`为界限分大小内存 ），free函数释放

  ​		小内存使用内存池进行分配，

  ​		内存中有两块区域：堆区与栈区，在定义变量时，变量名存放于栈区，变量值存放于堆区，内存管理回收的则是堆区的内容，
  
  