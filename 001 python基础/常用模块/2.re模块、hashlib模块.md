[TOC]

# re模块

正则：判断、验证、查找

获取匹配：在字符串中查找满足条件的内容

```python
re.findall(表达式，字符串)：查找所有满足条件的内容
re.search(表达式，字符串)：从头开始，只找一个
```

非获取匹配：仅仅用于判断字符串是否符合规则（返回bool值）

```python
re.match(表达式，字符串)：从头开始，匹配不上就不管了
```

重复匹配：

*：任意次数		+：1~无穷 次		？：0~1 次		{a，b}  最小a次，最多b次

分组：优先获取括号内的内容	（？：）	      ？：可取消优先级

贪婪匹配： * 或 +

非贪婪匹配：表达式加  ？

```python
import re

# print(re.findall('alex','hahahah alex is alex is dsb'))
#                                                alex

# print(re.findall('\w','Aah123 +-_'))
#                               \w
# print(re.findall('\w\w','Aah123 +-_'))
#                                \w\w
# ['Aa','h1','23',]

# print(re.findall('\w9\w','Aa9h123 aaa9c+-_'))
#                                   \w9\w
# ['a9h','a9c']

# print(re.findall('\W','Aah123 +-_'))
# print(re.findall('\s','Aah\t12\n3 +-_'))
# print(re.findall('\S','Aah\t12\n3 +-_'))
# print(re.findall('\d','Aah\t12\n3 +-_'))
# print(re.findall('\D','Aah\t12\n3 +-_'))


# print(re.findall('\w\w\d\d','asfdasdfegon001adfadfegon002asdfxx01 yy02'))

# print(re.findall('\s','Aah\t12\n3 +-_'))
# print(re.findall('\t','Aah\t12\n3 +-_'))
# print(re.findall('\n','Aah\t12\n3 +-_'))


# ^: 仅从头开始匹配
# print(re.findall('^alex',' alex is alex is alex'))
#                        ^alex

# $: 仅从尾部开始匹配

# print(re.findall('alex$',' alex is alex is alex1'))
#                                           alex$


# .: 代表匹配一个字符,该字符可以是除换行符之外任意字符
# print(re.findall('a.c','a a1c aaac a c asfdsaf a\nc',re.DOTALL))
#                                      a.c
# ['a1c','aac','a c','a\nc']

# []:代表匹配一个字符,这一个字符是来自于我们自定义的范围
# print(re.findall('a[0-9]c','a,c a a1c a9c aaac a c asfdsaf a\nc',re.DOTALL))
# print(re.findall('a[a-zA-Z]c','a,c aAc a1c a9c aaac a c asfdsaf a\nc',re.DOTALL))
# print(re.findall('a[a-zA-Z]c','a,c aAc a1c a9c aaac a c asfdsaf a\nc',re.DOTALL))
# print(re.findall('a[+*/-]c','a,c a+c a-c a*c a/c aAc a1c a9c aaac a c asfdsaf a\nc',re.DOTALL))
# print(re.findall('a[+*\-/]c','a,c a+c a-c a*c a/c aAc a1c a9c aaac a c asfdsaf a\nc',re.DOTALL))

# print(re.findall('a[^0-9]c','a,c a a1c a9c aaac a c asfdsaf a\nc',re.DOTALL))



# 重复匹配
# ?:代表左边那一个字符出现0次到1次
# print(re.findall('ab?','a ab abb abbbb a123b a123bbbb'))
#                                            ab?
# ['a','ab','ab','ab','a','a']

# *: 代表左边那一个字符出现0次到无穷次
# print(re.findall('ab*','a ab abb abbbb a123b a123bbbb'))
#                                            ab*
# ['a','ab','abb','abbbb','a','a']

# +: 代表左边那一个字符出现1次到无穷次
# print(re.findall('ab+','a ab abb abbbb a123b a123bbbb'))
#                                      ab+
# ['ab','abb','abbbb']

# {n,m}:代表左边那一个字符出现n次到m次
# print(re.findall('ab{1,3}','a ab abb abbbb a123b a123bbbb'))
# ['ab', 'abb', 'abbb']
# print(re.findall('ab{1,}','a ab abb abbbb a123b a123bbbb'))
# print(re.findall('ab+','a ab abb abbbb a123b a123bbbb'))

# print(re.findall('ab{0,}','a ab abb abbbb a123b a123bbbb'))
# print(re.findall('ab*','a ab abb abbbb a123b a123bbbb'))

# print(re.findall('ab{3}','a ab abb abbbb a123b a123bbbb'))


# .*: 匹配任意0个到无穷个字符,贪婪匹配
# print(re.findall('a.*c','a123213123asdfasdfc123123123123+-0)((c123123'))
#                        a.*c

#.*?:匹配任意0个到无穷个字符,非贪婪匹配
# print(re.findall('a.*?c','a123213123asdfasdfc123123123123+-0)((c123123'))


#|:或者
# print(re.findall('companies|company','Too many companies have gone bankrupt,c and the next one is my company'))
#                                                                                                    companies|company

#():分组
# print(re.findall('compan(?:ies|y)','Too many companies have gone bankrupt,c and the next one is my company'))
#                                                                                                compan(ies|y)

# print(re.findall('href="(.*?)"','<p>动感视频</p><a href="https://www.douniwan.com/1.mp4">逗你玩呢</a><a href="https://www.xxx.com/2.mp4">葫芦娃</a>'))
#                                              href=".*?"


#                'a\\c'
# print(re.findall('a\\\\c','a\c aac'))
# print(re.findall(r'a\\c','a\c aac'))


# print(re.findall('alex','my name is alex Alex is dsb aLex ALeX',re.I))


#忽略大小写
# print(re.findall('alex','my name is alex Alex is dsb aLex ALeX',re.I))

# msg="""
# my name is egon
# asdfsadfadfsadf egon
# 123123123123123egon
# """
# print(re.findall('egon$',msg,re.M)) #my name is egon\nasdfsadfadfsadf egon\n123123123123123egon'

#re模块其他方法
# res=re.findall('(href)="(.*?)"','<p>动感视频</p><a href="https://www.douniwan.com/1.mp4">逗你玩呢</a><a href="https://www.xxx.com/2.mp4">葫芦娃</a>')
# print(res)
#
# res=re.search('(href)="(.*?)"','<p>动感视频</p><a href="https://www.douniwan.com/1.mp4">逗你玩呢</a><a href="https://www.xxx.com/2.mp4">葫芦娃</a>')
# print(res)
# print(res.group(0))
# print(res.group(1))
# print(res.group(2))
#
#
# res=re.match('abc','123abc') ## res=re.search('^abc','123abc')
# print(res)
#
# print(re.findall('alex','alex is alex is alex'))
# print(re.search('alex','alex is alex is alex'))
# print(re.match('alex','alex is alex is alex'))
#
# pattern=re.compile('alex')
# print(pattern.findall('alex is alex is alex'))
# print(pattern.search('alex is alex is alex'))
# print(pattern.match('alex is alex is alex'))


# ['1', '2', '60', '-40.35', '5', '-4', '3']
msg="1-2*(60+(-40.35/5)-(-40*3))"
print(re.findall('\D?(-?\d+\.?\d*)',msg))

# msg="1-2*(60+(-40.35/5)-(-40*3))"
#            \D?-?\d+\.?\d*

```

```
base62_decode
微博mid,uid获取
def gid_to_mid(url):
    url = str(url)[::-1]
    size = len(url) / 4 if len(url) % 4 == 0 else int(len(url) / 4) + 1
    result = []
    for i in range(size):
        s = url[i * 4: (i + 1) * 4][::-1]
        s = str(base62_decode(str(s)))
        s_len = len(s)
        if i < size - 1 and s_len < 7:
            s = (7 - s_len) * '0' + s
        result.append(s)
    result.reverse()
    return int(''.join(result))
url = 'https://weibo.com/1178975384/H7kdmo6q2'

# 获取微博mid
def get_mid(url):
    if '?' in url:
        url = url.split('?')[0]
    mid = re.search(r'weibo.cn/(\d{8,11})/(\d{16,16})', url)
    print('1',mid)
    if mid:
        return mid.groups()[1]
        print(mid.groups()[1])

    mid = re.search(r'weibo.com/(\d{8,11})/(\w{9,9})', url)
    print('2',mid)
    if mid:
        print(mid.groups()[1])
        return gid_to_mid(mid.groups()[1])
    mid = re.search(r'weibo.cn/detail/(\d{16,16})', url)
    print('3',mid)
    if mid:
        return mid.groups()[0]
        print(mid.groups()[0])
    mid = re.search(r'weibo.cn/status/(\d{16,16})', url)
    print(mid)
    if mid:
        return mid.groups()[0]
        print(mid.groups()[0])
    return 0
```



# hashlib模块

1.什么是hash

hash是一种算法，该算法接受一系列的数据，经过运算会得到一个hash值

2.三大特性：

- 只要传入的内容一样，那么得到的hash值一定是一样
- 只要采用hash算法固定，无论传入的内容多大，hash值的长度是固定
- hash值不可逆，即不能通过hash值逆推出内容

3.为何要用hash

特性1+2=》文件完整性校验

特性3==》

**基本模板**：

```python
import hashlib
m=hashlib.md5()
m.update("str".encode("utf-8"))
m.hexdigest
```

例子：

```python
import hashlib

# m=hashlib.md5()
# m.update('你好'.encode('utf-8'))
# m.update('hello'.encode('utf-8'))
# print(m.hexdigest()) #65c83c71cb3b2e2882f99358430679c3
#
# m1=hashlib.md5()
# m1.update('你好hello'.encode('utf-8'))
# print(m1.hexdigest()) #65c83c71cb3b2e2882f99358430679c3
# print(len(m1.hexdigest())) #32

# m2=hashlib.sha512()
# m2.update(b'asdfassssssssssssssssssssssssssss')
# print(m2.hexdigest())
# print(len(m2.hexdigest()))



#
# with open(r'D:\脱产5期内容\day17\今日内容',mode='rb') as f:
#     m=hashlib.md5()
#     for line in f:
#         m.update(line)
#     print(m.hexdigest())
pwd=input('password>>> ').strip()
m=hashlib.md5()
m.update('天王盖地虎'.encode('utf-8'))
m.update(pwd.encode('utf-8'))
m.update('一行白鹭上青天'.encode('utf-8'))
print(m.hexdigest())

```

- ```
  import hashlib
  a='202003091525079825-2020022723232233225233323123-219-1583739906'
  print(hashlib.md5(a.encode(encoding='utf-8')).hexdigest())
  #c881ec93f8ea2c6c06ad44897b4567f8
  ```
