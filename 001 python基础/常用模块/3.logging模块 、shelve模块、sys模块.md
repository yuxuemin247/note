[TOC]

# logging模块

1.什么是logging

​	日志记录：对时间点发生的事进行记录

2.为何要用logging

​	用日志是为了复查，提取有用信息

3.如何用logging

日志的级别，从低到高分别是：

1.debug		10	调试信息（用于记录程序在开发过程中的调试记录）

2.info		20	普通信息（普通的信息记录）

3.warning	30	警告信息（当某些操作可能发生错误时，就记录为警告信息，涉及一些敏感操作时（删库））

4.error		40	错误信息（当程序遇到错误时，记录为错误信息，（输入非法））

5.critical		50	严重错误（当程序遇到问题，无法执行时记录为严重错误，（核心组件缺失））

logging用数字来表示级别，从低到高		0	10	20	30	40	50

分级的意义：当日志数量变多时，通过分级就可以快速得到想要查看的日志

**系统默认打印的是 warning**

### **logging模块的四种核心角色：**

1.Logger	日志生成器	负责产生一条完整的日志

2.Filter		过滤器		负责对日志进行过滤

3.Handler	处理器		负责将日志输出到指定位置

4.Formater	格式化		负责处理日志显示格式	

**一条日志的生命周期：**

1.由Logger产生日志

2.交给过滤器进行过滤

3.交给Handler按照Formater的格式进行输出

**使用：**

```python
from conf import loggin_config
import logging.config
# 加载日志配置 获取日志生成器
logging.config.dictConfig(loggin_config.LOGGING_DIC)
logger = logging.getLogger("atm")


logger.info("%s 登录成功!" % name)
logger.error("%s 登录失败! 原因:%s" % (name,msg))
```

字典配置logging(重点)
字典的内容重点 但是不需背
记住如何来加载配置

**字典：**

```python
standard_format = '[%(asctime)s][%(threadName)s:%(thread)d][task_id:%(name)s][%(filename)s:%(lineno)d]' \
                  '[%(levelname)s][%(message)s]' #其中name为getlogger指定的名字

simple_format = '[%(levelname)s][%(asctime)s][%(filename)s:%(lineno)d]%(message)s'

id_simple_format = '[%(levelname)s][%(asctime)s] %(message)s'

logfile_path = "dictconfig.log"

LOGGING_DIC = {
    'version': 1,
    # 是否禁用已存在的生成器  这个值保持为False
    'disable_existing_loggers': False,
    # 四个key不能随便写 是固定
    'formatters': {
        # standard 表示格式化处理器的名字  相当于变量名称 可以随便写
        'standard': {
            # format是固定的不能随便写
            'format': standard_format
        },
        'simple': {
            'format': simple_format
        },
    },
    'filters': {},
    'handlers': {
        #打印到终端的日志
        #console是处理器的名称 可以随便写
        'console': {
            'level': 'DEBUG',
            'class': 'logging.StreamHandler',  # 打印到屏幕
            'formatter': 'simple'
        },
        #打印到文件的日志,收集info及以上的日志
        'default': {
            'level': 'DEBUG',
            'class': 'logging.handlers.RotatingFileHandler',  # 保存到文件
            'formatter': 'standard',
            'filename': logfile_path,  # 日志文件
            'maxBytes': 1024*1024*5,  # 日志大小 5M
            'backupCount': 5, #日志文件最大个数
            'encoding': 'utf-8',  # 日志文件的编码
        },
        "ATM":{
            'level': 'DEBUG',
            'class': 'logging.handlers.RotatingFileHandler',  # 保存到文件
            'formatter': 'standard',
            'filename': "ATMlog.txt",  # 日志文件
            'maxBytes': 1024*1024*5,  # 日志大小 5M
            'backupCount': 5, #日志文件最大个数
            'encoding': 'utf-8',  # 日志文件的编码
        }
    },
    'loggers': {
        #logging.getLogger(__name__)拿到的logger配置
        #aa是生成器的名称 可以随便写
        # 如果将key(生成器名称)设置为空 则意味着将它作为默认的是你生成器
        '': {
            'handlers': ['default', 'console'],  # 这里把上面定义的两个handler都加上，即log数据既写入文件又打印到屏幕
            'level': 'DEBUG',
            'propagate': True,  # 向上（更高level的logger）传递 日志的继承
        },
        "atm":{
            'handlers': ['ATM'],  # 这里把上面定义的两个handler都加上，即log数据既写入文件又打印到屏幕
            'level': 'DEBUG',
            'propagate': True,  # 向上（更高level的logger）传递 日志的继承
        }
    },
}
```

```python
# 了解知识点

# 自己来定义四种核心角色

import logging
mylog = logging.getLogger("father")
mylog.setLevel(10)

handler = logging.FileHandler("father.log")
mylog.addHandler(handler)
handler.setLevel(10)

fmter = logging.Formatter(fmt="%(threadName)s %(funcName)s %(module)s %(filename)s %(levelname)s %(asctime)s %(message)s")
handler.setFormatter(fmter)

# 在获取一个生成器  同时指定该生成器的父生成器是father这个生成器
sonlog = logging.getLogger("father.son")

# 需求:子生成器 的输出位置与父生成器不同  格式相同
sonhandler = logging.FileHandler("son.txt",encoding="utf8")
sonlog.addHandler(sonhandler)



sonfmt = logging.Formatter(fmt="%(threadName)s %(funcName)s %(module)s %(filename)s %(levelname)s %(asctime)s %(message)s")
sonhandler.setFormatter(sonfmt)



# 继承后子生成器 可以直接使用父生成器的配置

# mylog.info("这是一条日志信息!")
# sonlog.info("这是  son 输出的日志信息!")


#子生成器 在生成一个日志时  会自动给父生成器也发一个

# 取消传递效果
sonlog.propagate = False

sonlog.info("这是  son 输出的日志信息!")
```



例子：

```python

import logging

#简单的使用
# logging.debug("这是一条日志信息!") #没有输出任何内容
# 因为loggong模块为日志划分了级别  由于你输出的级别没有达到最低级别(warning)所以没有输出
# 为什么要设置最低等级  因为一些级别的日志  对我是无用的

# logging.info("info")
# logging.debug("debug")
# logging.warning("warning")
# logging.error("error")
# logging.critical("critical")

#默认情况下,级别为warning,输出的位置是控制台,默认的日志格式 为  级别:日志生成器的名称:调试的消息

# 如何修改默认的行为
# logging.basicConfig(filename="mylog.txt", # 指定的日志文件名
#                     filemode="a", #指定的是文件打开的模式  通常为a
#                     level=logging.DEBUG, # 指定级别
#                     format="%(filename)s %(levelname)s %(asctime)s %(message)s",# 指定显示格式
#                     )

# logging.info("info")
# logging.debug("debug")
# logging.warning("warning")
# logging.error("error")
# logging.critical("critical")

#需求: 有一个登陆注册 功能 需要记录用户操作日志, 程序员需要看到最详细的信息,而boss只需要看到简单的操作信息

#自定义四种核心角色  完成日志的输出
# 参数指定的是生成器的名称   (因为可以同时存在多个生成器)
# mylog = logging.getLogger("mylog")
# # 设置生成器的级别  低于该级别的不会生成
# mylog.setLevel(10)
#
# # 过滤器 这里不讲! 需要使用面向对象的基础知识点! (不常用)
#
# # 处理器
# handler = logging.FileHandler("youlog.txt",encoding="utf8",)
# #将处理器 绑定给生成器, add函数表明了  一个生成器可以添加多个处理器
# mylog.addHandler(handler)
#
#
# # 格式化处理器
# formater = logging.Formatter(fmt="%(filename)s %(levelname)s %(asctime)s %(message)s")
# # 将格式化处理器 绑定给  handler
# handler.setFormatter(formater)
#
# mylog.info("info")
# mylog.debug("debug")
# mylog.warning("warning")
# mylog.error("error")
# mylog.critical("critical")



# 实现  按照不同的格式输出到不同的文件中
# mylog = logging.getLogger("mylog")
# # 设置生成器的级别  低于该级别的不会生成
# mylog.setLevel(10)
#

# # 过滤器 这里不讲! 需要使用面向对象的基础知识点! (不常用)

# # 给程序员看的日志处理器
# handler1 = logging.FileHandler("youlog.txt",encoding="utf8",)
# #将处理器 绑定给生成器, add函数表明了  一个生成器可以添加多个处理器
# mylog.addHandler(handler1)
#
#
# # 给老板看的日志处理器
# handler2 = logging.FileHandler("boss.txt",encoding="utf8",)
# #将处理器 绑定给生成器, add函数表明了  一个生成器可以添加多个处理器
# mylog.addHandler(handler2)
#
#
# # 程序员的格式化处理器
# formater1= logging.Formatter(fmt="%(threadName)s %(funcName)s %(module)s %(filename)s %(levelname)s %(asctime)s %(message)s")
# # 将格式化处理器 绑定给  handler
# handler1.setFormatter(formater1)
#
#
# # 老板的格式化处理器
# formater2= logging.Formatter(fmt="%(levelname)s %(asctime)s %(message)s")
# # 将格式化处理器 绑定给  handler
# handler2.setFormatter(formater2)
#
#
# mylog.info("info")
# mylog.debug("debug")
# mylog.warning("warning")
# mylog.error("error")
# mylog.critical("critical")



# 现在需求已经实现了 但是 每次用日志都要写这么一堆代码,最好 能把配置写死 直接复制已有的配置信息

# logging.config 专门用于配置logging 模块
# import logging.config
#
# # 导入包含配置字典的模块
# import loggin_config
#
# # 通过一个字典来配置 logging模块
# logging.config.dictConfig(loggin_config.LOGGING_DIC)

# 通过名称 来获取一个生成器
# aaloger = logging.getLogger("aa")
#
# # 输出日志
# aaloger.info("测试信息!")


# # 当要获取的名称不存在时 会返回一个默认的生成器
# aaloger = logging.getLogger("aasadsadsa")
#
# print(aaloger.name)
# # # 输出日志
# aaloger.warning("测试信息!")
```



# shelve模块

用于序列化的模块，只有一个函数 open，用于打开一个文件。

打开以后 操作方式与字典完全一致,你可以把它当成字典,而且自带buff的字典,可以字典给完成序列化

同样支持 python所有的基础数据类型

该模块序列化得到的数据  只能被该模块使用 其他语言没有这个模块 所有无法使用  即无法跨平台

当你写的程序是一个单机程序时 可以考虑

后期 只要设计到数据交换 就应该使用json

例子：

```python
import shelve

# s = shelve.open("test.she")
# s["name"] = "爱跟"


# s = shelve.open("test.she")
# s["dic"] = {"age":20}

# s = shelve.open("test.she")
# print(s["dic"])
```



# sys模块

system的缩写，表示系统

用于添加环境变量		sys.path

调用解释器参数		sys.argv

```python
import sys
#添加环境变量
sys.path.append("文件路径")
# 用于接收操作系统调用解释器时传入的参数

# 当你要开发一款基于CMD的程序时 就需要使用这个属性了   因为一些操作系统没有界面  只能通过CMD来使用
print(sys.argv)

# 用于退出解释器  0表示正常退出
# 3.sys.exit(0)



print(sys.version)

print(sys.platform)

# 需求 开发一个基于CMD的复制文件的工具
# 第一个参数表示被执行的py文件   第二个作为源文件路径  第三个作为目标文件的路径
#
# source_path = 3.sys.argv[1]
# target_path = 3.sys.argv[2]
#
# print(source_path)
# print(target_path)
#
#
# with open(source_path,"rb") as f:
#     with open(target_path,"wb") as f1:
#         while True:
#             data = f.read(1024)
#             if not data:
#                 break
#             f1.write(data)

# 总结  3.sys 处理与python解释器相关的一些操作
# 常用的两个
# 添加环境变量  3.sys.path
# 获取调用解释器参数 3.sys.argv

```

