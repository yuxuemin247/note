[TOC]

# 一、os 模块

os 表示操作系统，主要处理与操作系统相关的操作

在操作系统中，最常用的就是对**文件及文件夹的操作**，当操作文件及文件夹时，就需要用到**os模块**。

重点放在对文件的增删改查

```python
import os

os.getcwd()						#获取当前执行文件所在的文件夹路径
os.chdir('dirname')				#修改当前执行文件的工作目录
os.curdir						#获取当前目录字符串名：('.')
os.pardir						#获取当前目录的父目录字符串名：('..')
os.makedirs('a/b/c')			#创建多级目录，如果中间的目录不存在则自动创建
os.mkdir('c1/a1/b1')			#只能创建单级目录，上一级文件夹必须存在
os.rmdir('dirname')				#删除文件夹，前提是文件夹为空
os.remove('文件路径')	   		 #删除一个文件
os.listdir('dirname')			#列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印
os.stat('path/filename')		#获取文件/目录信息
os.sep							#获取操作系统特定的路径分隔符，win为'\\',linux为'/'
os.linesep						#获取当前平台使用的行终止符，win为'\t\n',linux为'\n'
os.system('bash command')		#运行shell命令，直接显示
os.environ						#获取系统环境变量

os.removedirs('dirname')	#若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推
os.rename('oldname','newname')	#重命名文件/目录				
os.pathsep						#输出用于分割文件路径的字符串，win为;linux为:
os.name							#输出字符串指示当前使用平台。win->'nt';linux->'posix'
```

```python
#删除文件夹，先要把文件夹的内容删除，再删文件夹

#要删除的文件路径
path=r'D\day19\b'

for f in os.listdir('b')
	f_path=path+'\\'+f	#listdir 得到的是文件名称，需手动拼接成完整路径
    os.remove(f_path)	
os.rmdir('b')
```

# 二、os.path模块

path：路径		该模块用于处理路径

python是跨平台的，各平台的路径书写方式不同，所以将所有与路径相关都进行了封装，该模块可以实现路径在不同品台下的自动转换,从而实现跨平台。

只要涉及到**文件或文件夹路径**，就应该用 **os.path 模块**

主要处理路径，不关心路径是否存在，只是做拼接、剪切、转换等操作

通常是与os一起使用

优点：用它处理的路径是可以跨平台的

```python
import os

os.path.abspath(path)	#返回path规范化的绝对路径
os.path.split(path)		#将path分割成目录和文件名，以元组返回
os.path.dirname(path)	#返回path的目录，就是os.path.split(path)的第一个元素
os.path.basename(path)	#返回path最后的文件名，如果path以/或\结尾，即返回空值。
os.path.exists(path)	#如果path存在，返回True；如果path不存在，返回False
os.path.isabs(path)		#如果path是绝对路径，返回True。 第一个字符为路径分割符，则表示为绝对路径
os.path.isfile(path)	#如果path是一个存在的文件，返回True，否则返回False
os.path.isdir(path)		#如果path是一个存在的目录，则返回True，否则返回False
os.path.jion(path1[,path2[,...]])	#将多个路径组合后返回，最后一个盘符之前的参数将被忽略
os.path.getsize(path)	#返回path的大小
os.path.getatime(path)	#返回path所指向的文件或者目录的最后存取时间
os.path.getmtime(path)	#返回path所指向的文件或者目录的最后修改时间
```

```python
#规范化路径
os.path.normcase(r'D:/day19/path模块/path模块.py')	#规范化路径，大写变小写，反斜杠变正斜杠
os.path.normpath(r'D:/day19/path模块/path模块.py')	#反斜杠变为正斜杠，返回上一目录
```

# 三、subprocess模块

subprocess：子进程，进程是一个正在运行的程序，子进程是由另一个正在运行程序启动的程序

当我们有一个任务需要处理，而自己的程序无法处理，所以需要开启另一个程序

当要在python程序中**执行系统指令**时 就应该使用**subprocess**

当你需要再python中启动一个子进程，并用它进行数据交互时就使用subprocess

如果不需要数据交互，可以使用os.system

```python
import subprocess
# dir 表示要执行命令
# shell 表示dir是一个命令
# stdout 指定输出管道（用于进程之间的数据传输）
# stdin 表示输出交给子进程的数据
# stderr 表示子进程发送的错误信息

p=subprocess.Popen('dir',shell=True,stdout=subprocess.PIPE)
p.stdout.read()		#启动dir子进程，指定输出结果到管道中
```

```python
import os 
os.system(r'D\Program Files (x86)\Tencent\QQ\Bin\QQScLauncher.exe')
os.system("dir")
#在执行系统指令时，也可以命令操作系统启动某个程序
```

os.system 在执行时，直接把结果输出到了控制台，无法获取执行结果

subprocess 不仅可以启动子进程，还能与子进程进行数据交互

```python
#启动一个tasklist子进程，指定输出结果到管道中
p1=subprocess.Popen('tasklist',shell=True,stdout=subprocess.PIPE)

#启动一个findstr的子进程，将p1进程的结果作为p2进程输入
p2=subprocess.Popen('findstr cmd',	#要执行的指令
                    shell=False,	#第一个参数是否是一个指令
                    stdin=p1.stdout,#指定输入管道
                    stdout=subprocess.PIPE,	#指定输出管道
                    stderr=subprocess.PIPE)	#表示错误管道，当进程执行出错时，可以在错误管道中获												取结果
#读取p2进程的结果
print(p2.stdout.read())
print(p2.stderr.read().decode('GBK'))
```

# 四、configparser模块

configparser：**配置解析，用来解析配置文件**

配置文件：用于编写程序的配置信息的文件

配置信息：程序中需要用到的值交给用户来确定

配置信息的数据需要满足的条件：

1.数据的值不是固定的

2.可以由用户来指定的

**配置文件的编写格式：**

第一种：section 分区 方括号中是分区的名称

第二种：option 选项 名称=值

**注意**：

不能出现重复的分区名

同一个分区下不能有相同的选项名

值可以是任何类型 且字符串不需要加引号



作为配置文件 最常用的操作就是读取 很少会做修改

read 读取配置文件

add_section 添加分区

set 如果没有这个选项则添加

remove_section 删除分区

remove_option 删除选项

```python
import configparser
cfg=configparser.ConfigParser()			#创建一个配置文件解析器
cfg.read('test.cfg',encoding='utf-8')	#读取名为test.cfg的配置文件

cfg.sections()	#获取分区
username=cfg.get('mysql','username')  #获取某个分区下的某个选项，第一个参数分区名 第二个选项名称

#以下三个函数封装了类型转换
cfg.getfloat()		#转换浮点型
cfg.getint()		#转换整型
cfg.getboolean()	#转换bool类型

options=config.options('section1')	#查看标题section1下所有key=value的key
item_list=config.items('section1')	#查看标题section1下所有key=value的(key,value)格式
val=config.get('section1','user')	#查看标题section1下user的值=>字符串格式
```

读取配置信息		两步

1.读取某个配置文件

2.调用get函数

**添加、删除、修改**

```python
import configparser
cfg=configparser.ConfigParser()
cfg.read("test.cfg",encoding="utf-8")

cfg.set('mysql','lock','true')		#将mysql分区下的lock改为True

with open('test.cfg',encoding='utf-8') as f:
    cfg.write(f)

cfg.add_section('新分区')	#添加新的分区

cfg.remove_section("新分区")			  # 删除分区
cfg.remove_option("mysql","port")		# 删除某个分区的选项

print(cfg.has_section("mysql"))		# 判断是否存在某个分区
print(cfg.has_option("mysql","username"))	# 判断是否存在某个选项	
```

# 五、shutil模块

封装了文件高级操作的工具包，可直接完成**copy、获取文件信息、压缩与解压缩**等操作

```python
import shutil
shutil.copyfile(src,dst)	#拷贝文件，提供两个文件路径

shutil.copyfileobj   		#拷贝文件 提供两个文件对象 长度表示缓冲区大小
shutil.copymode()  			#拷贝文件权限 提供两个文件路径
shutil.copystat(src, dst) 	#拷贝文件状态信息 最后访问 最后修改 权限 提供两个文件路径
shutil.copy(src, dst) 		#拷贝文件和权限   提供两个文件路径
shutil.copy2(src, dst) 		#拷贝文件和状态信息 提供两个文件路径

shutil.ignore_patterns("mp3","*.py")
shutil.copytree(src, dst, symlinks=False, ignore=None) 拷贝目录  
#symlinks默认False将软连接拷贝为硬链接  否则拷贝为软连接

shutil.rmtree 				#删除目录 可以设置忽略文件
shutil.move(src, dst)   	#移动目录和文件
```

压缩与解压缩

```python
import shutil
#只支持zip和tar格式
#压缩,  文件名 格式  需要压缩的文件所在文件夹
shutil.make_archive("压缩测试","zip",r' 需要压缩的文件所在文件夹')
#解压缩   文件名  解压后的文件存放目录
shutil.unpack_archive("压缩测试.zip",r'解压后的文件存放目录')
```

