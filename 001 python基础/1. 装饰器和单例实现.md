- [TOC]
  
  装饰器
- 用一个函数或类装饰另一个函数或类为其提供额外的能力
  - 额外的能力通常都是跟正常业务逻辑没有必然联系的横切关注功能
  
- 作用
  - `Django`框架那些中间件
  - 登录检查、参数检查、缓存(声明式缓存)、代理、上下文提供者

- ##### 不带参数的装饰器(计算时间)

  - 函数实现

  ```
  import time
  
  def decorate(func):
  	@wraps(func)  #消除参数名改变，以及可以使用不带装饰器的原函数
  	def wrapper(*args,**kwargs)
  		start_time = time.time()
          result = func(*args,**kwargs)
  		print('花费时间',time.time()-start_time)
          return result 
      return wrapper
  ```

  - 类实现

  ```
  class decorate:
  	def __init(self,func):
  		self.func = func
       
       def __call__(self,*args,**kwargs):
       		start_time = time.time()
       		result = self.func(*args,**kwargs)
       		print('花费时间'，time.time()-start_time)
       		return result
  
  ```

- ##### 带参数的装饰器

  - 函数实现

  ```
  import time
  def recode_time(make_record):
      def decorate(func):
          def wrapper(*args, **kwargs):
              start_time = time.time()
              result = func(*args, **kwargs)
              make_record(time.time() - start_time)
              return result
          return wrapper
      return decorate
  
  def console_output(duration):
      print(f'花费时间{duration}')
  
  def file_output(duration):
  	with open('xxx.log','a') as f:
  		f.write('花费时间',duration)
  
  @recode_time(console_output)
  def download(url):
      print(f'开始下载{url}')
      time.sleep(2)
      print(f'下载完成{url}')
  
  download(url='1232131')
  ```
  
- ##### 用装饰器创建单例():

  单类：让一个类只能创建唯一的实例

  ```
  from threading import RLock
  #RLock reentrant 可重入锁，
  def singleton(cls):
      instance = {}
      lock =RLock()
  
      @wraps(cls)
      def wrapper(*args,**kwargs):
          with lock:
          	if cls not in instance:
          		instance[cls] = cls(*args,**kwargs)
              return instance[cls]
      return wrapper
  
  @singleton
  class President:
      def __init	__(self,name,duration):
          self.name = name
          self.duration = duration
          
      def __str__(self):
          return f'{self.name}:{self.duration}年'
          
  #instance虽然是局部变量，但生命周期还没有结束，因为闭包,一个局部变量变成了全局变量。在单线程环境下，可以保证是单例
  #多线程下并不是线程安全的代码，所以要加锁
  
  p1 = President('Luo',4)
  p2 = President('Hun',5)
  p3 = President('xu',6)
  
  print(p1,p2,p3)
  
  print(id(p1),id(p2),id(p3))
  ```

- ##### 用元类创建单例

  ```python
  class SingletonMeta(type):     #普通类是继承object,元类是继承type
  
      def __init__(cls,*args,**kwargs):  
          cls.__instance = None
  
      def __call__(cls,*args,**kwargs):
          if not cls.__instance:
              cls.__instance = super().__call__(*args,**kwargs)
          return cls.__instance
  
  
  class President(object,metaclass=SingletonMeta):
      
      def __init__(self,name,age):
          self.name = name
          self.age = age
      
      def __str__(self):
          return f'{self.name}: {self.age}年'
      
  p1 = President('张三',11)
  p2 = President('李四',12)
  
  print(p1 == p2)
  print(id(p1),id(p2))
  ```

  

