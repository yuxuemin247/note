##### `1、pep8`规范

- 代码编排： 缩进4个字节，行长 80
- 函数间 /函数内/文件结尾 空行
- 单行不要import导入多个库，模块内用不到的不要import
- 注释
  - 函数和类尽可能添加`__doc__`
  - 引入外来算法或者配置时需在注释中添加源链接，表明出处
  - 单行注释，块注释
- 命名
  - 包名 、模块名、函数名、方法名全部使用小写，用下划线连起来
  - 类名、异常名使用`capwords`的方式，异常名结尾加Error或`Wraning`后缀
  - 全局变量尽量使用大写，一组同类型的全局变量要加上统一前缀。
  - 常量全部使用大写
  - 函数名必须有动词如do_something的局势
  - 自定义的变量名、函数名不要与标准库中的名字冲突
  - `pip install pep8`



##### 2、深浅拷贝

- ```python
  a = [1, 2, 3]
  b = [a] * 3 #[ [1,2,3],#直接对列表乘积，是列表增长，元素1，2，3变多，所以这里[] [1,2,3],[1,2,3]]
  print(b)
  c = copy(b)
  d = deepcopy(b)
  e = loads(dumps(b,4))
  b[1].append(999)  #[[1,2,3,999],[1,2,3,999],[1,2,3,999]]  因为[1,2,3]同一个内存地址
  c[1].append(999)  #[[1,2,3，999，999],[1,2,3,999,999],[1,2,3，999，999]]
  d[1].append(999) #[[1,2,3，999],[1,2,3,999],[1,2,3，999]]  #深拷贝 所有跟上面的不是同一个，但他们内部用的时同一个
  e[1].append(999) #[[1,2,3，999],[1,2,3,999],[1,2,3，999]]  #序列化存到文件中，取出来类似于深拷贝
  # 所有跟上面的不是同一个，但他们内部用的时同一个
  ```

- 对于不可变对象来说不存在深复制,浅复制，都是直接引用，地址是一样的。

- 浅拷贝（copy()）：拷贝父对象，不会拷贝对象的内部的子对象,子对象只是引用计数增加

  深拷贝（ `copy.deepcopy()`）：完全拷贝父对象跟子对象

  对于单层的可变对象来说它两都一样，如果可变对象内层嵌套了可变对象，浅拷贝只复制最外层，开辟内存空间，引用内层的，深拷贝全部复制，开辟内存空间。

##### 3、迭代器，生成器

- 可以直接for-in 循环的数据类型都被称为可迭代对象（`iterable`)

  `list、set、tuple、dict 、string` 是可迭代对象，不是迭代器

  `l2=iter(list1)`  将可迭代对象转换为迭代器

- iterator:任何实现了`__iter__`和`__next__`方法的对象都是迭代器

  - `__iter__`返回迭代器自身
  - `__next__`返回容器的下一个值
  - 如果容器中没有更多元素，则会抛出`Stoplterration`异常

- `generator`:这种一边循环一边计算的机制，称为生成器，生成器其实是一种特殊的迭代器，不需要自定义`__iter__`和`__next__`

  - 生成器函数（使用了yield），遇到yield时函数会暂停保存当前的所有运行信息，并在下一次执行`__next_-`方法时从当前位置运行
  - 生成器表达式 ：（表达式 for var in 可迭代对象）#返回一个生成器对象
  - 调用一个生成器函数返回的是一个迭代器对象

- 自定义一个迭代器，实现斐波那契数列

  ```
  class Fib(object):
  	def __init__(self,max):
  		self.x = 0
  		self.y = 1
  		self.max = max
  	def __iter__(self):
  		return self 	#返回当前对象
  	
  	def __next__(self):
  		n_next = self.y 
  		self.x,self.y =self.y, self.x +self.y
  		if self.max > self.x:
  			return n_next
  		else:
  			raise StopIteration()			
  ```

- 自定义一个生成器函数，实现斐波那契数列

  - ```
    def fib(max):
    	x = 0
    	y = 1
    	while y < max :
    		yield y
    		x,y = y, x+y
    ```

- 迭代器、生成器有什么好处？

  - 节省内存，
  - 惰性求值，延迟计算



##### 4、列表、字典、集合的推导

​	`list1=[1,2,3,4,5,6]`

- 列表推导式

  - [`表达式  for i  in  list1  if 条件` ]   #if条件可没有
    - `list2=[ i+1 for i in list1 if i % 2 == 0`]#不满足条件就直接过滤了，不输出
  - [`表达式1 if 条件 else 表达式2  for i  in list1`]
    - `list2 = [i+1 if x%2==0 else i+2 for i in list1 ]`
  - [`表达式 1 for x  in  list1 for y in list1` ] 
    - `list1 = [ x+y for x in list1 for y in list2]`

  列表推导式里面的`list1 `  可以是 列表字典集合

- 字典推导式

  - 字典本身没有办法完成的操作，只能借助新字典

  ```
  dict1 ={'a':59,'b':79,'c':88}
  new_dict = {v:k for k,v in dict1.items()}
  new_dict1 = {k:v for k,v in dict1.items() if v>60}
  ```


##### 5、高阶函数

​		如果一个函数的参数是另外一个函数，那么这个函数就可以称为高阶函数

###### map

map是系统内置函数，map函数接收两个参数，一个是函数，一个是可迭代对象(`Iterable`)，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。

```
"""
map(function,iterable)
参数1：function，函数,函数的参数个数取决于后面序列的个数
参数2：iterable，一个序列或多个序列

功能：将传入的函数依次作用于序列中的每一个元素，并把结果作为新的Iterator返回
"""
#1.传入函数一个参数
def fun(x):
    return  x ** 2

#需求：获取一个列表中每个元素的平方，生成一个新的列表
l1 = map(fun,[1,2,3,4])
print(l1)   #<map object at 0x000001E86D3DA6D8> #返回的是迭代器
print(list(l1))  #[1, 4, 9, 16]  #将迭代器转换为迭代对象

#传入函数2个参数
l1 = [1,2,3,4]
l2 = [2,3,4,5,6,7]
def mul(x, y):
    return x * y
#注意如果两个列表长度不一样，以短的为主计算，函数是平行取值，也就是说x取l1的值，y取l2的值
gen1 = map(mul,l1,l2)  #可以使用lambda表达式
print(list(gen1))  #[2, 6, 12, 20]

#提取字典的键
gen3 = map(lambda x:int(x),{'1':10,'2':20})
print(list(gen3)) #[1,2]

#元组
gen4 = map(lambda x,y:(x,y),[1,2,3,4,5],[1,2,3])
print(list(gen4))  #[(1, 1), (2, 2), (3, 3)]

```

###### filter

filter是内建函数，可以对可迭代对象进行过滤，去除不满足条件的元素

```python
filter(function, iterable) 
参数： function 确定是否保留元素，返回True|False，为真保留，为假去除元素,function的值可以None
      iterable 可迭代对象
返回值：一个新的迭代器或迭代对象
#1 过滤掉非字符串数据
print(filter(lambda x:isinstance(x,str),['1',8,'2',3,True,0.9])) 
等价于:
  [s for s in ['1',8,'2',3,True,0.9] if isinstance(s,str)]
  
#2 回文数
#回文数判断
def is_palindrome(n):
    l1 = list(str(n))  #将数字转换为字符串，再将字符串转为列表
    l2 = l1[::-1] 	   #获取反向列表
    if l1 == l2:       #列表比较,长度相同，每一个元素都相同则为真
        return True
    return False

#找出1-1000内所有的回文数
print(list(filter(is_palindrome,range(1,1001))))
 
```

###### sorted

sorted是内建函数，用于对有序序列进行排序，生成一个新序列

```python
sorted(iterable[, key][, reverse]) 
参数：iterable  排序对象，可以列表、元组、字符串等有序序列
      key 一个函数，作用于序列的每一个元素，根据函数返回值进行排序，
           具体的函数的参数就是取自于可迭代对象中，
      reverse 默认从小到大排序，如果reverse为True则从大到小排序
返回值： 新的序列
#字符串排序
print(sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower)) #指定把元素变为小写后再排序

#多维数据排序
l=[('a', 1), ('b', 2), ('c', 6), ('d', 4), ('e', 3)]
print(sorted(l,key=lambda x:x[1]))  #使用元组的第二个元素排序

students = [{'name':'abc','gender':'男','age':23} ,
            {'name': 'kkd', 'gender': '男', 'age': 19} ,
            {'name': 'ccxsbc', 'gender': '男', 'age': 20}]
print(sorted(students,key=lambda elem:elem['age']))  #指定用age排序

```

###### reduce

reduce()函数也是`functools`模块中的一个高阶函数。需要引入`functools`模块才能使用。

```python
'''
functools.reduce(f, iterable[, initializer])
参数1：函数，这个函数需要两个参数。
参数2：可迭代对象
参数3：可选，是默认值
返回值：f函数计算的结果
'''
from functools import reduce
#1.累加求和
def f(x,y)
    return x + y
print(reduce(f,[1,2,3,4,5],5))
计算过程：
 （1）a = f(1,2)  #将1赋值给x，2赋值给y
 （2）a = f(a,3)  #a赋值给x，3赋值给y
 （3）a = f(a,4)
  (4）a = f(a,5)
  (5）f(d,10) = 20

#将序列变成整数
print(reduce(lambda x,y:x*10+y,[9,0,7,8])) #9078
```

##### 6、lambda

lambda是一个匿名函数，就是没有函数名的函数，lambda 结构比较简单能够支持的功能十分有限，一般在高阶函数中使用较多。lambda  参数1，参数2，参数xxx  ：返回结果    



##### 7、排列和组合

- 排列  从n个不同元素中取出m（m≤n）个元素，按照一定的顺序排成一列，叫做从n个元素中取出m个元素的一个排列(Arrangement)。特别地，当m=n时，这个排列被称作全排列(Permutation)，其值为n!/(n-m)!

- 组合  从n个不同的元素中，任取m（m≤n）个元素为一组，叫作从n个不同元素中取出m个元素的进行组合，计算公式：n!/(m!*(n-m)!)

  ```
  import itertools
  #排列
  mylist = list(itertools.permutations([1,2,3,4], 2))
  print(mylist)
  print(len(mylist))
  
  #组合
  mylist = list(itertools.combinations([1,2,3,4,5], 5))
  print(mylist)
  print(len(mylist))
  
  #笛卡尔积
  #repeat 重复3次
  mylist = list(itertools.product("QWERTYUIOP", repeat=3))
  print(mylist)
  print(len(mylist))
  ```







