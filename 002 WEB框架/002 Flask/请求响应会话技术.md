## Day02

#### 1.request

```
request是一个内置对象
内置对象：不需要创建就可以直接使用的对象
属性
	method  
		请求方法
	base_url
		不包含get请求参数的url
	host_url
		只有主机和端口号的url
	url
		完整的请求地址
	path
  	请求路径，不包含 主机，端口号 和 请求参数
	remote_addr
		请求的客户端地址
		
	一般情况下  get请求方式都是在浏览器的地址栏上显示的
	eg：http：//www.baiduc.com/s?name=zs&age=18
	获取get请求方式的参数的方式：
	request.args.get('name')
	
  
  1. args
  - get请求参数的包装，args是一个ImmutableMultiDict对象，类字典结构对象
  - 数据存储也是key-value
  - 外层是大列表，列表中的元素是元组，元组中左边是key，右边是value
         
     

2. form
- 存储结构与args一致
- 默认接收post参数
      request.form.get('name')
	  一般情况下 post请求方式都是通过表单形式使用的
      eg：
        <form action='xxx' method='post'>
                <input type='text' name='name'>
      获取post请求方式的参数的方式    
	files   **   form标签中有一个参数 enctype=maltipart/form-data  请求方式必须是post  使用files接收
		文件上传
		
	headers	
		请求头
		
	path
		路由中的路径
		
	cookies
		请求中的cookie
		
	session	
		与request类似  也是一个内置对象  可以直接打印 print（session）
```

#### 2 Response

```
创建方式
	返回字符串
		如果只有字符串，就是返回内容，数据
		还有第二个返回，放的是状态码
		@blue.route('/response/')
        def get_response():
               return '德玛西亚',404
	
	render_template
		渲染模板
		将模板变成字符串
		@blue.route('/rendertemplate/')
        def render_temp():
              resp = render_template('Response.html')
              print(resp)
              print(type(resp))
              return rese,500
	
	make_response
		Response对象
		返回内容
		状态码
		@blue.route('/makeresponse/')
		def  make_resp():
              resp = make_response('<h2>xxxxxxxx</h2>',502)
              print(type(resp))
              return rese
	
	redirect
		重定向
		@blue.route('/redirect/')
        def  make_redir():
             return redirect('/makeresponse/')
		反向解析 url_for
		@blue.route('/redirect/')
		def  make_redir():
       		return redirect(url_for('first.make_resp'))

```

##### 异常

```
abort
	直接抛出 显示错误状态码  终止程序运行
	abort(404)
	eg:
		@blue.route('/makeabort/')
         def make_abort():
              abort(404)    #abort跟其他一样，后面的也不执行
              return '天还行'
```

```
捕获
	@blue.errorhandler()
		- 异常捕获
		- 可以根据状态或 Exception进行捕获
		- 函数中要包含一个参数，参数用来接收异常信息
	eg:
	@blue.errorhandler(502)
    def handler502(exception):
        return '不能让你看到状态码'
```

#### 3.会话技术

```
1.请求过程Request开始，到Response结束
2.连接都是短连接
3.延长交互的生命周期
4.将关键数据记录下来
5.Cookie是保存在浏览器端/客户端的状态管理技术
6.Session是服务器端的状态管理技术
```

##### cookie

```
Cookie
	1.客户端会话技术
	2.所有数据存储在客户端
	3.以key-value进行数据存储层
	4.服务器不做任何存储
	5.特性
		支持过期时间
			max_age
			expries
		根据域名进行cookie存储
		不能跨网站（域名）
		不能跨浏览器
		自动携带本网站的所有cookie
	6.cookie是服务器操作客户端的数据
	7.通过Response进行操作
```

```
cookie登陆使用
	设置cookie    response.set_cookie('username',username)
		eg:
		 	resp = render_template('Response.html')
		 	resp.srt_cookie('username',username)
		#要用响应对象才能设置cookie
	获取cookie    username = request.cookies.get('username','游客')
		request
	删除cookie     response.delete_cookie('username')
		#要用响应对象才能删除 cookie
```

##### session

```
Session
	1.服务端会话技术
	2.所有数据存储在服务器中
	3.默认存在服务器的内存中
		- django默认做了数据持久化（存在了数据库中）
	4.存储结构也是key-value形势，键值对
	【注】单纯的使用session是会报错的，需要使用在__init__方法中配置app.config['SECRET_KEY']=‘110’
```

```
session登陆使用
	设置    session['username'] = username
	获取    session.get('username')
	删除
		   resp.delete_cookie('session')
		   session.pop('username')
```

##### session持久化问题

```
Session
	- django中对session做了持久化，存储在数据库中
    - 可以修改到redis中
		flask中没有对默认session进行任何处理
    - flask-session 可以实现session的数据持久化
    - 推荐使用redis
        - 需要安装 redis 客户端，pip install redis
	服务端会话技术
	Flask中没有对默认Session进行处理，默认存在内存中
	Session需要持久化  Redis中
	实现方案
		插件 flask-session
		pip install flask-session
		在国内源安装
			pip install flask-sessin -i https://pipy.douban.com/simple
		初始化Session对象 
			配置init中app.config['SESSION_TYPE'] = 'redis'
				持久化的位置
			初始化
				创建session的对象有2中方式 分别是以下两种
				1 Session(app=app)
				2 se = Session()   se.init_app(app = app)
			安装redis
				pip install redis
			需要配置SECRET_KEY='110'
			其他配置--视情况而定
				app.config['SESSION_KEY_PREFIX']='flask:session'
				app.config['PERMANENT_SESSION_LIFETIME'] = datetime.timedelta(days=7)
		查看redis内容
			redis-cli
			keys *
			get key
			ttl key
	session生存时间31天	
		ttl session
			flask的session的生存时间是31天，django的session生存时间是15天
```

