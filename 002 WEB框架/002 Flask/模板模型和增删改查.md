## 
#### 1.Template

```
简介：
	MVC中的View，MTV中的Template
	主要用来做数据展示的
	模板处理过程分为2个阶段
            1 加载
            2 渲染
     jinja2模板引擎
            1.本质上是html
            2.支持特定的模板语法
            3.flask作者开发的   一个现代化设计和友好的python模板语言  模仿的django的模板引擎
            4.优点
                    速度快，被广泛使用
                    HTML设计和后端Python分离
                    减少Python复杂度
                    非常灵活，快速和安全
                    提供了控制，继承等高级功能

```

```
模板
	1.静态html   前后端分离
	2.模板语言动态生成的html
		{{ var }}  变量的接收
			从views传递过来的数据，前面定义出来的数据
		案例
			www.jq22.com/cdn/
		
	3、结构标签
		{% block  名字%}
	
		{% endblock %}
				
					首次出现挖坑操作
					第二次出现填坑操作
					第N次出现，填坑操作，会覆盖前面填的坑
					不想被覆盖，需要添加 {{ super() }}
	4、extends
		继承
	{% extends 'abc.html'%}
	
	5、include
	包含，将其他html包含进来
	将一个指定的模板代码块包含进来
	例如:
    {% include 'footer.html' %}
	
	
	6、宏定义
		macro
		可以在模板中定义，调用函数
        无参
        {% macro say()%}
        你饿了吗？？？
        {% endmacro %}
        有参
        {% macro createUser(name,age)%}
        欢迎{{ name }} 心理没点数吗 你都{{ age }}大了
        {% endmacro %}
							
            外文件中的宏定义调用需要导入也可以include

{% macro getUser(name)%}
欢迎光临红浪漫{{ name }},拖鞋手牌拿好,楼上2楼左转,男宾一位
{% endmacro %}
{% from ‘html文件’ import yyy %}
{{ getUser('action') }}
			
7、循环控制
				for
					{% for .. in %}
					loop  循环信息
						索引  index
						第一个   first
						最后一个last
					{% endfor %}
				if
					{% if ..%}
					if 
					else
					elif
					{%  enfif %}

8、过滤器 
	{{ 变量|xxx|yyy|zzz }}
	没有数量限制
	语法:
    {{ 变量 | 过滤器 | 过滤器 }}

例如:
    {# 当变量未定义时，显示默认字符串，可以缩写为d #}
    <p>{{ name | default('No name') }}</p>
 
    {# 单词首字母大写 #}
    <p>{{ 'hello' | capitalize }}</p>
 
    {# 单词全小写 #}
    <p>{{ 'XML' | lower }}</p>
 
    {# 去除字符串前后的空白字符 #}
    <p>{{ '  hello  ' | trim }}</p>
 
    {# 字符串反转，返回"olleh" #}
    <p>{{ 'hello' | reverse }}</p>
 
    {# 格式化输出，返回"Number is 2" #}
    <p>{{ '%s is %d' | format("Number", 2) }}</p>
 
    {# 关闭HTML自动转义 #}
    <p>{{ '<em>name</em>' | safe }}</p>
    
    {# 四舍五入取整，返回13.0 #}
    <p>{{ 12.8888 | round }}</p>
 
    {# 向下截取到小数点后2位，返回12.88 #}
    <p>{{ 12.8888 | round(2, 'floor') }}</p>
 
    {# 绝对值，返回12 #}
    <p>{{ -12 | abs }}</p>

    {# 取第一个元素 #}
    <p>{{ [1,2,3,4,5] | first }}</p>
 
    {# 取最后一个元素 #}
    <p>{{ [1,2,3,4,5] | last }}</p>
 
    {# 返回列表长度，可以写为count #}
    <p>{{ [1,2,3,4,5] | length }}</p>
 
    {# 列表求和 #}
    <p>{{ [1,2,3,4,5] | sum }}</p>
 
    {# 列表排序，默认为升序 #}
    <p>{{ [3,2,1,5,4] | sort }}</p>
 
    {# 合并为字符串，返回"1 | 2 | 3 | 4 | 5" #}
    <p>{{ [1,2,3,4,5] | join(' | ') }}</p>
    
其他: 
    default 默认值
    capitalize 首字母大写
    lower 全小写
    upper 全大写
    trim 去除空格
    reverse 反转
    format 格式化输出
    safe 关闭转义(已审查，没有安全隐患)
    striptags 将值中标签去掉
    round 四舍五入(截取)
    abs 绝对值
    first 第一个元素
    last 最后一个元素
    length 列表长度
    sum 列表求和
    sort 列表排序(升序)
    join 合并字符串
				# 定义一个自定义的 过滤器
                @bp.app_template_filter(name='mycut')
                def mycut(x):
    				return x if len(x) < 6 else x[:6] + '...'
```

#### 2.models

```

1.数据交互的封装
2.Flask默认并没有提供任何数据库操作的API
	Flask中可以自己的选择数据，用原生语句实现功能
		原生SQL缺点:
              代码利用率低，条件复杂代码语句越过长，有很多相似语句
              一些SQL是在业务逻辑中拼出来的，修改需要了解业务逻辑
              直接写SQL容易忽视SQL问题
	也可以选择ORM
		SQLAlchemy
		将对象的操作转换为原生SQL
		优点
			 易用性，可以有效减少重复SQL
             性能损耗少
             设计灵活，可以轻松实现复杂查询
             移植性好
3.Flask中并没有提供默认ORM
	ORM 对象关系映射
	通过操作对象，实现对数据的操作
```

```
flask-sqlalchemy
     使用步骤：1.pip install flask-sqlalchemy
              2.创建SQLALCHEMY对象
                ①：db=SQLAlchemy(app=app)
                ②：db=SQLAlchemy()  这句话一般会放到models中  因为需要db来调用属性 				       	   db.init_app(app=app) 这句话放在 init或ext中
              3.config中配置  SQLALCHEMY_DATABASE_URI
               'dialect+driver://username:password@host:port/database'
                数据库 + 驱动 :// 用户:密码@ 主机:端口/数据库
                mysql是需要全部配置          				 app.config['SQLALCHEMY_DATABASE_URI']='mysql+pymysql://scott:tiger@localhost:3306/mydatabase'
                sqlite
                    轻量级数据库，配置简单 sqlite的路径
                    sqlite:///+ os.path.join(app.root_path, 'sqlite3.db')
                执行
                    db.create_all()
                        有坑
                            primary-key
                                添加主键
        		关闭 SQLAlchemy 底层对象监听功能
         		app.config[‘SQLALCHEMY_TRAKE_MODIFICATIONS’]=False
         		打印 SQL 语句
         		app.config['SQLALCHEMY_ECHO'] = True
                  
```

```
使用：
	定义模型
			继承Sqlalchemy对象中的model
	如果想自己增加功能 ，建立 ModelMixin 类，然后模型继承这个类
	定义字段
              主键
                  一定要添加
              所需要字段
              语法
                  db.Column( db.类型（）,约束 )
    创建
	db.create_all()
	删除
	db.drop_all()
	修改表名
	__tablename__ = "Worker"
```

#### 3.模型定义

```
数据定义
	字段
		db.Integer 整型
		db.String (size) 字符串，size 为最大长度，比如db.String(20)
		db.Text 长文本
		db.DateTime 时间日期，Pythondatetime对象
		db.Float 浮点数
		db.Boolean 布尔值
		
	约束
		primary_key     unique + not null
			主键
		autoincrement    mysql  auto_increment   				
		主键自增长		  oracle  sequence
		unique           
			唯一
		default            boolean
			默认 
		index            
			索引
		nullable
			非空
		boolean
		 布尔值
		ForeignKey        
			外键
			用来约束级联数据
			db.Column( db.Integer, db.ForeignKey('表名.id') )
			使用relationship实现级联数据获取
				声明级联数据
				backref="表名"
				lazy=True
	def __repr__(self):
        """
        自定义模型对象的 打印格式
        :return:
        """
        return '<User, id:{}, name:{}, age:{}>'.format(self.id, self.name, self.age)
```

#### 4.flask-migrate / 模型迁移

```
使用
	安装
		pip install flask-migrate
	初始化
		创建migrate对象
		需要使用app 和 db初始化  
			 migrate = Migrate()
			 migrate.init_app(app=app, db=db)
		懒加载初始化
		结合flask-script使用
		在manage上添加command (MigrateCommand)
			manager.add_command("db", MigrateCommand)
	python manager.py db xxx
		init     第一次使用,初始化迁移目录
		migrate  生成迁移文件
				不能生成
					模型定义完成从未调用
					数据库已经有模型记录
		upgrade  升级
		downgrade 降级
```

#### 5.CRUD

```
增
	创建对象
	放到数据连接的session进行commit
		db.session.add()
			   eg:
			   @blue.route("/addperson/")
                def add_person():
                    p = Person()
                    p.name = "小明"
                    p.age = 15
                    db.session.add(p)
                    db.session.commit()
                    return "添加成功"
		db.session.add_all()
		        eg:
		        @blue.route("/addpersons/")
                def app_persons():
                    persons = []
                    for i in range(5):
                        p = Person()
                        p.name = "猴子请来的救兵%d" % random.randrange(100)
                        p.age = random.randrange(70)
                        persons.append(p)
                    db.session.add_all(persons)
                    db.session.commit()
                    return "添加成功"
```

```
删除
	db.session.delete(对象)
		基于查询
```

```
修改
	先查到 person = Person.query.get(3)
		  person.name ='老王'
		  db.session.add(person)  可选
		  db.session.commit()
		基于查询
```

```
查
获取单个数据
	get
		# 根据主键查找获得对象，如果主键不存在，则返回 None
		person = Person.query.get(3)	
	first  #取出第1条数据，获取不到返回None
		person = Person.query.first()
```

```
获取结果集
	xxx.query.all 
		#返回的是一个列表，包含所有对象
		persons = Person.query.all()
		
		只返回指定字段
		persons = Person.query.with_entities(Person.name,Person.sex).all()
		
		distinct 按照字段去重
   		persons = Persons.query.with_entities(distinct(persons.age)).all()
		
	xxx.query.filter_by
		persons = Person.query.filter_by(age=15)
		返回类型为 BaseQuery，print 这个返回值会打印 SQL 语句，
		注意不能这样直接persons.name要使用.first()  .all()
		
	xxx.query.filter
		persons = Person.query.filter(Person.age < 18)
		persons = Person.query.filter(Person.age.__le__(15))
		persons = Person.query.filter(Person.name.startswith("小"))
		persons = Person.query.filter(Person.name.endswith("1"))
		persons = Person.query.filter(Person.name.contains("1"))
		persons = Person.query.filter(Person.age.in_([15, 11]))
		返回类型为 BaseQuery，print 这个返回值会打印 SQL 语句，
		注意也不能直接使用用persons.name 要使用.first()  .all()
		
BaseQuery 要获得实例对象要在后面加 .first()/.all()
```

```
数据筛选
	order_by
		persons = Person.query.order_by("age")
		persons = Person.query.order_by(db.desc("age"))
	limit
		persons = Person.query.limit(5)
	offset
		persons = Person.query.offset(5).order_by("id")
	offset和limit不区分顺序，offset先生效
		persons = Person.query.order_by("id").limit(5).offset(5)
		persons = Person.query.order_by("id").limit(5)
		persons = Person.query.order_by("id").offset(17).limit(5)
	order_by 需要先调用执行
		 persons = Person.query.order_by("id").offset(17).limit(5)
```

```
逻辑运算
	与
		    and_     filter(and_(条件))
			huochelist = kaihuoche.query.filter(and_(kaihuoche.id == 1,kaihuoche.name == 'lc'))

	或
		or_          filter(or_(条件))
			huochelist = kaihuoche.query.filter(or_(kaihuoche.id == 1,kaihuoche.name =='lc'))

	非
		not_         filter(not_(条件))  注意条件只能有一个
			huochelist = kaihuoche.query.filter(not_(kaihuoche.id == 1))

	in
		    huochelist = kaihuoche.query.filter(kaihuoche.id.in_([1,2,4]))


```

#### 6.分页

```
 	原生
	persons = Person.query.offset((page_num - 1) * page_per).limit(page_per)
	pagination
	
	分页器	
	page = int(request.args.get('page', 1))
	persons = Person.query.paginate(page, per_page, False)
	persons =persons.items
方法:paginate，分页查询
参数:
	page:当前的页码
	per_page:每页的条数
	error_out:当查询出错时是否报错
	
返回值: 
	分页对象，包含了了所有的分页信息
	
Pagination: 
	属性:
		page:当前页码 
		per_page:每页的条数，默认为20条 
		pages:总页数
		total:总条数 
		prev_num:上页的页码 
		next_num:下页的页码 
		has_prev:是否有上一页 
		has_next:是否有下一页 
		items:当前页的数据

```

	方法: 
	iter_pages:返回一个迭代器器，在分页导航条上显示的页码列列表
	prev:上页的分页对象
	next:下一的分页对象
#### 7、分页显示的宏

```
{# 分页显示的宏 #}
{% macro pagination_widget(pagination, endpoint) %}
    <ul class="pagination">
        <li{% if not pagination.has_prev %} class="disabled"{% endif %}>
            <a href="{% if pagination.has_prev %}{{ url_for(endpoint,page = pagination.page - 1, **kwargs) }}
            {% else %}#{% endif %}">&laquo;
            </a>
        </li>
        {% for p in pagination.iter_pages() %}
            {% if p %}
                {% if p == pagination.page %}
                    <li class="active">
                        <a href="{{ url_for(endpoint, page = p, **kwargs) }}">{{ p }}</a>
                    </li>
                {% else %}
                <li>
                    <a href="{{ url_for(endpoint, page = p, **kwargs) }}">{{ p }}</a>
                </li>
                {% endif %}
            {% else %}
            <li class="disabled">
                <a href="#">&hellip;</a>
            </li>
            {% endif %}
        {% endfor %}
        <li{% if not pagination.has_next %} class="disabled"{% endif %}>
            <a href="{% if pagination.has_next %}{{ url_for(endpoint,page = pagination.page + 1, **kwargs) }}{% else %}#{% endif %}">&raquo;</a>
        </li>
    </ul>
{% endmacro %}
```

#### 8、context_processor(模板的全局变量)

```
import time


@app.context_processor
def client_ip():
  return dict(remote_ip=request.remote_addr)

@app.context_processor
def get_current_time():
  	def get_time(fmt="%b %d, %Y - %H:%M:%S"):
    	return time.strftime(fmt)
  	return dict(current_time=get_time)


<p>Current Time is: {{ current_time() }}</p>
<p>Current Day is: 	{{ current_time("%Y-%m-%d") }}</p>
  
# 在任意模板页面都可以是使用 current_time 这个额函数
```
