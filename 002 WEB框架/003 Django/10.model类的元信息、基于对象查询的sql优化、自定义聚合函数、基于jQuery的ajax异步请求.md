[TOC]

## ORM补充

## 一、Model类的元信息

```python
'''
1. Model类可以通过元信息类设置索引和排序信息
2. 元信息是在Model类中定义一个Meta子类
'''""""""
class Meta:
    # 自定义表名
    db_table = 'table_name'
    # 联合索引
    index_together = ('tag1', 'tag2')
    # 联合唯一索引
    unique_together = ('tag3', 'tag4')
    # 排序字段
    ordering = 'ordering_tag'
    # /admin/中显示的表名称
    verbose_name = 'table_name'

```

## 二、基于对象查询的sql优化

```python
'''
1. 语法：only('tag_name1', ..., 'tag_name2') | defer('tag_name1', ..., 'tag_name2')
2. 属于QuerySet的方法
3. 用来优化面向对象查询的sql
4. only代表哪些字段参与查询，defer表示哪些字段不参与查询
'''
'''
# 好处：信息存放在对象中，取值方便
# 坏处：所有字段都进行查询
# uq1 = Uesr.objects.all()
# print(uq1)
# print(uq1.query)

# only: 只取规定的字段形成对象（查主键）
# uq11 = Uesr.objects.all().only('name', 'age')
# print(uq11)
# print(uq11.query)
# print(uq11.first().name)
# print(uq11.first().gender)  # 自己又重新执行了查询该字段的sql
'''
'''
# defer：只取规定的字段外的字段形成对象（查主键）
# uq12 = Uesr.objects.all().defer('name', 'age')
# print(uq12)
# print(uq12.query)

# 好处：只对所需字段进行查询
# 坏处：数据放在字典中，相比对象取值不是那么方便
# uq2 = Uesr.objects.values('name', 'age')
# print(uq2)
# print(uq2.query)
'''
```

## 三、自定义group_concat聚合函数

```python
from django.db.models import Aggregate, CharField
class Concat(Aggregate):
    function = 'GROUP_CONCAT'
    template = '%(function)s(%(distinct)s%(expressions)s)'

    def __init__(self, expression, distinct=False, **extra):
        super(Concat, self).__init__(
            expression,
            distinct='DISTINCT ' if distinct else '',
            output_field=CharField(),
            **extra)
```

## 四、基于jQuery的ajax异步请求

```html
<script src="jquery.js"></script>
<script>
    $.ajax({
        url: '请求路径',
        type: 'get|post',
        data: {
            // post请求数据
        },
        success: function(data) {
            // 请求的回调函数
        }
    })
</script>
```
