[TOC]

# 文章详情母版抽离 --- 点赞点踩 --- 评论区 --- xss 攻击

## 文章详情母版抽离

```python
'''
1. 与个人站点共有一个母版
2. 页面功能
	- 文章content的展示
	- 文章点赞点踩
	- 文章的根评论、子评论与评论展示
'''
```

```python
'''
models:
	Comment:
	create_time = models.DateTimeField(auto_now_add=True)
'''
'''
将site放入site文件夹，
创建site_base.html
site.html、article.html、menu_list.html 继承site_base.html
'''
```

自定义菜单列表

```html
// menu_list.html

<div class="panel panel-primary">
    <div class="panel-heading">文章分类</div>
    <div class="panel-body">
        {% for category_tuple in category_set %}
            <p>
                <a href="/{{ blog.site }}/category/{{ category_tuple.0 }}">{{ category_tuple.0 }}
                    ({{ category_tuple.1 }})</a>
            </p>
        {% endfor %}
    </div>
</div>
<div class="panel panel-info">
    <div class="panel-heading">文章标签</div>
    <div class="panel-body">
        {% for tag in tag_list %}
            <p>
                <a href="/{{ blog.site }}/tag/{{ tag.name }}">{{ tag.name }} ({{ tag.c }})</a>
            </p>
        {% endfor %}
    </div>
</div>
<div class="panel panel-danger">
    <div class="panel-heading">文章档案</div>
    {% for time in time_list %}
        <p>
            <a href="/{{ blog.site }}/archive/{{ time.month|date:'Y-m' }}">
                {{ time.month|date:'Y年m月' }}
                ({{ time.c }})
            </a>
        </p>
    {% endfor %}
</div>
```



```python
'''
自定义菜单列表：
templatetags > blog_tags.py :

from django.template import Library

from django.db.models import Count
from django.db.models.functions import TruncMonth

register = Library()


@register.inclusion_tag('site/menu_list.html', name='menu_list_tag')
def menu_list(blog):
    # 该站点下的分组与该分组下的文章数
    # [(py, 2), (h5, 1), (java, 1)]
    category_set = blog.category.all() \
        .filter(articledetail__article__blog=blog) \
        .values('name').annotate(c=Count('articledetail')) \
        .values_list('name', 'c')

    # print(category_set)

    # 标签
    # [{'name': '个人', 'c': 6}, {'name': '大牛', 'c': 5}, {'name': '技术', 'c': 6}]
    tag_list = blog.tag.all() \
        .filter(articledetail__article__blog=blog) \
        .values('name').annotate(c=Count('articledetail'))
    # print(tag_list)

    # 档案
    # [{'month': datetime.date(2018, 3, 1), 'c': 1}, {'month': datetime.date(2019, 2, 1), 'c': 2}, {'month': datetime.date(2019, 3, 1), 'c': 1}]>
    time_list = blog.article_set.all() \
        .annotate(month=TruncMonth('create_time')) \
        .values('month').annotate(c=Count('pk')).order_by('-month')
    # print(time_list)
    return {
        'category_set': category_set,
        'tag_list': tag_list,
        'time_list': time_list,
    }

'''
```

## 点赞点踩

步骤一

```python
'''
# 赞踩布局及样式
<div class="flag">
	<i class="up glyphicon glyphicon-thumbs-up active"></i>
	<i class="down glyphicon glyphicon-thumbs-down"></i>
</div>
.flag {
    position: fixed;
}
.up .down ...
.active {
    color: red; # 通过active类来切换赞踩状态
}

'''
```

步骤二

```python
'''
# 前台：根据赞踩情况，决定图标的显示
<div class="flag">
<!-- 未登录：空 | 登录未点赞点踩：None | 登录点踩了：{'is_up': True} | 登录点踩了：{'is_up': False} -->
	<i hidden class="is_login" style="color: black; font-size: 30px">{{ is_up }}</i>
    {% if is_up.is_up == True %}
    	<i class="up glyphicon glyphicon-thumbs-up active"></i>
        <i class="down glyphicon glyphicon-thumbs-down"></i>
    {% elif is_up.is_up == False %}
    	<i class="up glyphicon glyphicon-thumbs-up"></i>
    	<i class="down glyphicon glyphicon-thumbs-down active"></i>
    {% else %}
    	<i class="up glyphicon glyphicon-thumbs-up"></i>
    	<i class="down glyphicon glyphicon-thumbs-down"></i>
    {% endif %}
</div>

# 分析：
如果没有登录，前台获取不到is_up
如果登录，未操作赞踩，前台is_up：None
如果登录，且已赞，前台is_up：{'is_up': True}
如果登录，且已踩，前台is_up：{'is_up': False}
    
# 后台 article_page 视图函数
if request.user.is_authenticated():
	is_up = request.user.upordown_set.filter(article=article).values('is_up').first()
'''
```

步骤三

```python
'''
# 前台如何根据登录状态处理赞踩
$('.up').click(function () {
	// 未登录：空 => false
	// 登录未点赞点踩：None | 登录点踩了：{'is_up': True} | 登录点踩了：{'is_up': False} => true
	is_login = $('.is_login').text() ? true : false;
	if (!is_login) {
		alert("请登录！")
	} else {
		if (!$(this).hasClass('active')) {  // 保证点赞后不再重复点赞
			_this = this;
			// 不是点赞状态，发送点赞请求
			$.ajax({
				url: '/upordown/',
				type: 'get',
				data: {
					article_id: {{ article.id }},
					is_up: true,
				},
				success: function () {
					$(_this).addClass('active').next().removeClass('active');
				}
			})
		}
	}
})
$('.down').click...
# 总结：
# 1. 点赞点踩图标在登录后才能点击
# 2. 点赞点踩图标只有在自身未点亮时才可以触发自己的事件
# 3. 点赞发送is_up: true，点踩发送is_up: fasle
# 4. 后台处理数据库后，前台再修改图标样式状态
'''
```

步骤四

```python
def upordown(request):
    # 不管前台是否处理登录状态，后台一定需要处理，且不用装饰器
    if not request.user.is_authenticated():
        return JsonResponse({
            'status': 2,
            'msg': '请先登录',
            'data': {}
        })
	# 往下一定是登录后操作
    user = request.user
    is_up = request.GET.get('is_up', None)
    is_up = json.loads(is_up)  # 将前台的true|false转化为后台的True|False
    article_id = request.GET.get('article_id', None)

    # 某用户未对某文章进行过赞踩操作：点赞就是点赞，点踩就是点踩
    # 某用户已对某文章进行过赞踩操作：点赞就是赞增踩减，点踩就是踩增赞减
    # 获取用户是否赞踩过文章
    res = user.upordown_set.filter(article_id=article_id)

    with transaction.atomic():  # 会捕获事务中的所有SQL，一旦异常就会回滚
         # 操作文章表的up_count|down_count
    	# 操作upordown表的 user-article-is_up
        if not res: # 无记录
            if is_up:
                Article.objects.filter(pk=article_id).update(up_count=F('up_count') + 1)
            else:
                Article.objects.filter(pk=article_id).update(down_count=F('down_count') + 1)
            UpOrDown.objects.create(user=user, article_id=article_id, is_up=is_up)
        else: # 有记录
            if is_up:
                Article.objects.filter(pk=article_id).update(up_count=F('up_count') + 1)
                Article.objects.filter(pk=article_id).update(down_count=F('down_count') - 1)
            else:
                Article.objects.filter(pk=article_id).update(up_count=F('up_count') - 1)
                Article.objects.filter(pk=article_id).update(down_count=F('down_count') + 1)
            UpOrDown.objects.filter(user=user, article_id=article_id).update(is_up=is_up)
    return JsonResponse({
        'status': 1,
        'msg': 'ok',
        'data': {}
    })
```

## 评论区

布局

```html
<script>
        var parent_id = '';

        // 回复的点击事件
        $('.back_comment').click(function () {
            var username = $(this).attr('username');
            parent_id = $(this).attr('parent_id');
            {#alert("回复评论")#}
            $(".comment_content").val('@' + username + '\n')
        });

        // 评论脚本
        $("#submit").click(function () {
            var content = $('.comment_content').val();
            var index = content.indexOf('\n');
            content = content.slice(index + 1);

            if (content) {
                $.ajax({
                    url: '/add_comment/',
                    type: 'post',
                    data: {
                        csrfmiddlewaretoken: '{{ csrf_token }}',
                        article_id: {{ article.id }},
                        content: content,
                        parent_id: parent_id,
                    },
                    success: function (data) {
                        location.reload()
                    }
                })
            }

        })
    </script>
```

views:

```python
# 添加评论
def add_comment(request):
    if not request.user.is_authenticated():
        return JsonResponse({
            'status': 2,
            'msg': '请先登录',
            'data': {}
        })

    # 操作的数据库表: article的comment_count | comment的 user article content parent_id
    user = request.user
    article_id = request.POST.get('article_id', None)
    content = request.POST.get('content', None)
    parent_id = request.POST.get('parent_id', None)
    # print(article_id)
    # print(content)
    # print(parent_id)

    with transaction.atomic():
        Article.objects.filter(pk=article_id).update(comment_count=F('comment_count') + 1)
        Comment.objects.create(user=user, article_id=article_id, content=content, parent_id=parent_id)


    return JsonResponse({
        'status': 1,
        'msg': 'ok',
        'data': {}
    })
```

## XSS 攻击

```python
'''
在文本上写html代码，让其执行代码内容，写入死循环让浏览器崩溃，写入链接转跳进入病毒网站下载病毒
'''
'''
<h1>hehehe</h1>
<script>
alert(1)
alert(2)
alert(3)
</script>
'''
```

**bs4处理xss攻击**

```python
from bs4 import BeautifulSoup
# 1.转换成结构化字符串 
# html.parser是Python内置的一个解析器，当传入后会解析成一个结构的文档
soup = BeautifulSoup(content, 'html.parser')

# 2. 对整个标签进行修改操作
tag = soup.find('script')         #找到script标签
tag.clear()                       #只将script标签中的内容清空
tag.hidden = True                 #将script中标签和内容全部隐藏
content = soup.decode()    		 #将内容再转换成字符串

# 3.将处理后的content存到数据库
```

csrf 局部使用

```python
# 局部禁用csrf认证
from django.views.decorators.csrf import csrf_exempt, csrf_protect

# 添加文章正文图片
@csrf_exempt
def add_image(request):
    pass
```

