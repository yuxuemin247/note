[TOC]

# 路由分发

## 一、路由基础

```
'''
# 正则路径  视图函数地址  默认关键字参数（了解）  路由别名
# r'^index$' 只能匹配index，不能匹配index/
# r'^index/$' 只能匹配index/，也能匹配index(先拿index匹配，如果失败，会添加/再次匹配)

url(r'^index/$', views.index)
url(r'^testkw/$', views.testkw, {'num': 88888})  # def testkw(request, num):

#在django2.0路由使用path和re_path(类似于url，也使用正则)

# 路由匹配是否会默认添加/
# 'django.middleware.common.CommonMiddleware'
# APPEND_SLASH = False
'''
```

## 二、有名无名分组

```python
#路由参数匹配情况
# 无名分组：/testnoname/10/
url(r'^testnoname/(\d+)/$', views.testnoname)  

#def testnoname(request, var)  # var=10

# 有名分组：/testname/10/1/
url(r'^testname/(?P<num>\d+)/(?P<page>\d+)/$', views.testname)  
# def testname(request, page, num)  # page=1 num=10

# 注：不能混用


```

## 三、多app共存的路由分配

```python
'''
# 在主路由中药配置多个app，要对视图函数调用起别名
from app01 import views as app01_views
from app02 import views as app02_views

 url(r'^app01/test_page/$', app01_views.test_page),
 url(r'^app02/test_page/$', app02_views.test_page),
'''
```

## 四、多app共存时模板冲突问题

```python
方法1：在项目根目录下的templates中建立每一个应用同名的文件夹，每个应用的模板文件放在自己应用名文件夹下

使用：render(request, 'app_name/test.html')
'''
```

## 五、创建app流程

```python
'''
1. python3 manage.py startapp app_name
2. 去settings中配置INSTALLED_APPS， 添加记录：'app_name.apps.App_nameConfig'
注：app配置的顺序决定了（共同资源冲突下的）查找顺序
'''
```

## 六、路由分发(主子路由)

```python
'''
# 分担总路由的代码压力, 将每个app的自身路由配置交给app自己的ulrs.py来管理（分文件管理路由）

1.在每一个应用中建立自身的urls.py文件，语法同主路由
2.在主路由进行分发
from django.conf.urls import include
urlpatterns = [
    url(r'^app01/', include('app01.urls')),
    url(r'^app02/', include('app02.urls')),
]
# 注：主路由分发一定不能使用$正则语法 (错误eg: ^app01/$)
'''
#如果有问题，考虑主子路由，加name。
```

## 七、路由别名

```python
'''
1.有些路由会被大量访问(直接访问、间接访问)
2.这些路由可能后期还会发生变化
3.可以给路由设置别名，通过别名访问：<a href="{% url '路由别名' '传入有名无名分组所需参数' %}"></a>
'''
```

## 八、名称空间

```python
'''
主路由：
from django.conf.urls import include
urlpatterns = [
    url(r'^app01/', include('app01.urls', namespace='app01')),
    url(r'^app02/', include('app02.urls', namespace='app02')),
]

app01应用下路由
from django.conf.urls import url
from app01 import views
app_name = 'app01'
urlpatterns = [
    url(r'^test/', views.test, name='test')
]

app02应用下路由
from django.conf.urls import url
from app02 import views
app_name = 'app02'

urlpatterns = [
    url(r'^test/', views.test, name='test')
]

前端页面反向解析：{% url 'app01:test' %} | {% url 'app02:test' %}

视图函数reverse方法：url = reverse('app01:test') | url = reverse('app02:test')
'''
```

## 九、反向解析

```python
'''
from django.shortcuts import reverse
在视图函数中通过reverse方法反向解析出真实的路径

# 1.不带分组：url(r'可能会变的真实路由', 视图函数, name='路由别名')
url = reverse('路由别名')

# 2.无名分组：url(r'可能会变的真实路由(带无名分组)', 视图函数, name='路由别名')
url = reverse('路由别名', args=(给无名分组赋值))

# 3.有名分组：url(r'可能会变的真实路由(带有名分组)', 视图函数, name='路由别名')
url = reverse('路由别名', kwargs={给有名分组赋值，key就是有名分组名})
'''

在前端界面 <a href="{% url '路由别名' '传入有名无名分组所需参数' %}
```

## 十、2.x新特性

```python
'''
from django.urls import path, re_path
# 向下兼容，不建议使用url， 使用与url相同的re_path
from django.conf.urls import url
urlpatterns = [
    path('index/', views.index),
    # page/<int:msg>/   page/(?P<msg>(\d+))   # 访问/page/123/
    # path('page/<int:msg>/', views.page),
    # path('page/<str:msg>/', views.page),
    # path('page/<path:msg>/', views.page),
    # path('page/<slug:msg>/', views.page),
    path('page/<uuid:msg>/', views.page),
]

# 1. 2.x版本re_path的使用方式同1.x版本url
# 2. path写的是绝对字符串，请求地址必须与路由地址完全匹配
# 3. path拥有五个转换器：
	-- str：匹配除路径分隔符(/)外的字符串，默认
	-- int：匹配自然数
	-- slug：匹配字母、数字、横杠及下划线组成的字符串
	-- uuid：匹配uuid形式的数据
	-- path：匹配任何字符串，包括路径分隔符(/) (不能用?)

'''
```

## 十一、自定义转换器

```python
'''
# 原因：自定义正则匹配目标路径

语法：
1.自定义类
# 匹配11位的185电话
class CVT185phone:
	# 匹配过程
    regex = '185\d{8}'
    def to_python(self, value):
        return int(value)
	# 反解过程
    def to_url(self, value):
        return '%11d' % value

# 在主路由中
from django.urls import register_converter
from 所在路径 import CVT185phone
register_converter(CVT185phone, 'phone185')

path('page/<phone185:msg>/', views.page, name="pages")
'''
```

