[TOC]

# ajax请求----分页器

## 一、ajax请求数据

```python
'''
$.ajax({
    url: '/ajax/',  # 请求路径
    type: 'post',  # 请求方式
    data: {  # get和post都以data字典方式携带数据
        usr: $('.usr').val(),  # 获取输入框内容
        pwd: $('.pwd').val(),
    },
    success: function (data) {
        console.log(typeof(data), data);  # 得到后台返回的数据（普通字符串 | json类型数据）
    }
})
'''

'''
# ajax请求，后台只需要返回信息，所以不会出现render、redirect
def ajax(request):
    print(request.is_ajax())  # 是否是ajax请求
    if request.method == 'GET':  # 获取get请求数据
        usr = request.GET.get('usr', None)
        pwd = request.GET.get('pwd', None)
    if request.method == 'POST':  # 获取post请求数据
        usr = request.POST.get('usr', None)
        pwd = request.POST.get('pwd', None)
    
    # 返回字符串类型数据
    # return HttpResponse('OK')  # ***

    # 返回json类型数据
    dic = {'status': 'ok', 'msg': '登录成功'}
    data = json.dumps(dic, ensure_ascii=False)
    # 直接返回json模块处理后的json数据(json字符串)，前台接收到的是一个json类型的字符串，需要前台自己处理
    # return HttpResponse(data)
    # 返回json字符串是，还告诉前台，该数据就是json类型字符串，设置响应头
    return HttpResponse(data, content_type='application/json')  # ****
    
    from django.http import JsonResponse
    # 返回json类型数据的终极方法
    dic = {'status': 'ok', 'msg': '登录成功'}
    return JsonResponse(dic, safe=False, json_dumps_params={'ensure_ascii': False})  # *****
    # 参数含义：
    # 返回值保证是字典类型
    # safe在False情况下就支持返回列表或字符串
    # 取消json的dumps方法采用的默认ascii编码中文
'''
```

## 二、分页器

```python
from django.core.paginator import Paginator

# 分页对象列表
book_list = Book.objects.all()
# 分页对象
paginator = Paginator(book_list, 6)  # 分页对象列表，每一页对象(最大)数
# 对象总个数
count = paginator.count
# 总分页树
num_pages = paginator.num_pages

# 页码列表(可迭代对象)
page_range = paginator.page_range

# 某一具体页
page = paginator.page(3)  # 具体第几页
# 是否有上一页
page.has_previous()
# 上一页编码
page.previous_page_number()
# 是否有下一页
page.has_next()
# 下一页编码
page.next_page_number()
```



## 三、批量插入数据

```python
book_list = []
for i in range(100):
    book = Book(name='book%s' % i, price=11.11, publish_date='2018-1-1', publish_id=1)
    book_list.append(book)
# 操作对象列表，一次操作多少条数据
Book.objects.bulk_create(book_list, 20)  # 插入100条数据只需要执行5次sql
```

