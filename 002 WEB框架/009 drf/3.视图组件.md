[TOC]

# 视图组件  

## 基本视图

```python
'''
抽取基类
'''
class List():
    def list(self,request, *args, **kwargs):
        response = {'status': 100, 'msg': '查询成功'}
        books=self.model

        books_ser=self.model_ser(instance=books,many=True)
        response['data']=books_ser.data
        return Response(response)


class Create():
    def create(self,request, *args, **kwargs):
        response = {'status': 100, 'msg': '新增成功'}
        try:
            book_ser = self.model_ser(data=request.data)
            if book_ser.is_valid():
                book_ser.save()
                response['data'] = book_ser.data
            else:
                response['msg'] = book_ser.errors

        except Exception as e:
            response['msg'] = str(e)
        return Response(response)


class BooksView(List,Create,APIView):
    model=models.Book.objects.all()
    model_ser=BookSerializer
    def get(self, request, *args, **kwargs):
        return self.list(request, *args, **kwargs)

    def post(self,request):
        return self.create(request)


class BookView(APIView):
    def get(self, request, pk,*args, **kwargs):
        response = {'status': 100, 'msg': '获取成功'}
        book = models.Book.objects.all().filter(pk=pk).first()
        book_ser=BookSerializer(instance=book,many=False)
        response['data']=book_ser.data

        return Response(response)

    #修改某本书
    def put(self,request,pk):
        response = {'status': 100, 'msg': '修改'}
        book=models.Book.objects.filter(pk=pk).first()
        book_ser = BookSerializer(instance=book,data=request.data)
        if book_ser.is_valid():
            book_ser.save()
            response['data']=book_ser.data
        else:
            response['msg']=book_ser.errors
        return Response(response)
    def delete(self,request,pk):
        response = {'status': 100, 'msg': '删除成功','data':''}
        models.Book.objects.filter(pk=pk).delete()
        return Response(response)
```

## mixin类和generice类编写视图

```python
from rest_framework.mixins import CreateModelMixin,ListModelMixin,DestroyModelMixin,
RetrieveModelMixin,UpdateModelMixin
from rest_framework.generics import GenericAPIView

class BooksView(CreateModelMixin,ListModelMixin,GenericAPIView):
    serializer_class=BookSerializer
    queryset=models.Book.objects.all()
    def post(self,request,*args, **kwargs):
        return self.create(request,*args, **kwargs)
    def get(self,request,*args, **kwargs):
        return self.list(request,*args, **kwargs)
    
class BookView(RetrieveModelMixin,UpdateModelMixin,DestroyModelMixin,GenericAPIView):
    serializer_class=BookSerializer
    queryset=models.Book.objects.all()
    def get(self, request, *args, **kwargs):
        #获取单条
        return self.retrieve(request, *args, **kwargs)
    def put(self, request, *args, **kwargs):
        return self.update(request, *args, **kwargs)
    def delete(self,request, *args, **kwargs):
        return self.destroy(request, *args, **kwargs)
```

## 使用generics 下ListCreateAPIView,RetrieveUpdateDestroyAPIView

```python
from rest_framework.generics import ListAPIView,ListCreateAPIView,RetrieveUpdateDestroyAPIView,
DestroyAPIView,CreateAPIView
#它有两个接口，一个是获取所有，一个是新增
class BooksView(ListCreateAPIView):
    serializer_class=BookSerializer
    queryset=models.Book.objects.all()
    
class BookView(RetrieveUpdateDestroyAPIView):
    serializer_class=BookSerializer
    queryset=models.Book.objects.all()
```

## 使用ModelViewSet

```python
from rest_framework.viewsets import ModelViewSet
class BooksView(ModelViewSet):
    queryset=models.Book.objects.all()
    serializer_class=BookSerializer
```

## ViewSetMixin的使用

```python
'''
使用比较多， 其重写了as_view方法
'''
'''
url:
url(r'^test', views.Publish.as_view({'get':'aa'})),
'''
'''
view:
from rest_framework.viewsets import ViewSetMixin
class Publish(ViewSetMixin,APIView):
	def aa(self,request):
		return HttpResponse('aa')
'''
```

nginx的作用

![nginx](C:\Users\HASEE\Desktop\drf框架\img\nginx.PNG)

```python
'''
django项目的部署：
nginx + uwsgi + django
'''
```

```python
'''
产生一个空对象 --- > 调用 __new__ 方法
__init__ 方法，把数据初始化到对象内部
对象() ---> 调用 __call__ 方法
'''
```

# 认证组件

```python
'''
只有通过认证的用户才可以访问指定的url地址，即校验是否是我的登录用户
'''
```

## 实现认证

```python
'''
APIView的dispach方法---》self.initial(request, *args, **kwargs)
----》400行self.perform_authentication(request)
---》APIView的perform_authentication(request)----》request.user(request是新的request)
---->去Request类中找user,执行--->self._authenticate()(self是新的reqeust对象)
---->Request类的_authenticate(self)方法，深度
'''
```

## 使用认证功能

```python
'''
-写一个类,MyAuthetication
-写两个方法,一个是authenticate,一个是authenticate_header
-在authenticate方法中写认证逻辑,认证通过,返回空,认证不通过,抛异常
'''
class MyAuthetication():
    def authenticate(self,request):
        token=request.GET.get('token')
        ret=models.UserToken.objects.filter(token=token).first()
        if ret:
            return None
        else:
            raise AuthenticationFailed('您没有通过认证')
     def authenticate_header(self,xx):
        pass
'''
比如某个视图类需要登陆后才能查看,只需要在视图类加入:
'''
authentication_classes=[MyAuthetication]
```



扩展：

```python
__str__ 与 __repr__ 的区别： __str__ 返回一个适用于eval()的字符串，__repr__ 返回的字符串能够通过eval()来生成一个一样的对象。

代理：就是一个中介，A和B本来可以直连，中间插入一个中介C

正向代理：类似跳板机，代理访问外部资源		----------> 客户端代理
	用途：
        1.访问原来无法访问的资源，如google
        2.可以做缓存，加速访问资源
        3.对客户端访问授权，上网进行认证
        4.代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息
        
反向代理：实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器
									----------> 服务端代理
	用途：
        1.保证内网的安全，阻止web攻击，大型网站，通常将反向代理作为公网访问地址，Web服务器是内网
        2.负载均衡，通过反向代理服务器来优化网站的负载

```

