[TOC]

# 分页器

## 简单分页

视图层：

```python
--------------------------------utils.py-----------------------------

#封装一个通用的响应类
class CommonResponse():
    def __init__(self):
        self.status = 100
        self.msg = None

    @property
    def get_dic(self):
        return self.__dict__
    
---------------------------------MySerializer.py----------------------------
from rest_framework import serializers
from app01 import models
from rest_framework.exceptions import ValidationError


class AuthorSerializer(serializers.Serializer):
    class Meta:
        model = models.Author
        fields = '__all__'



class BookSerializer(serializers.ModelSerializer):
    class Meta:
        model = models.Book

        fields = '__all__'


class PublishSerializer(serializers.ModelSerializer):
    class Meta:
        model = models.Publish
        fields = '__all__'


--------------------------------------views.py-------------------------------
from app01.utils import CommonResponse
from app01.MySerializer import BookSerializer
from rest_framework.views import APIView
# 第一步,导入分页类
from rest_framework.pagination import PageNumberPagination
class MyPageNumberPagination(PageNumberPagination):
    page_size=4

class BooksView(APIView):
    def get(self, request):
        response = CommonResponse()
        book_list = models.Book.objects.all()

        # 第二步，实例化产生一个分页类对象，不需要传参数
        page_pagination = PageNumberPagination()
        # *****重点，4个参数
        page_pagination.page_size=4
        # 控制查询第几页的查询参数
        page_pagination.page_query_param='xx'
        page_pagination.page_size_query_param='max'
        # page_pagination.max_page_size=7

        # 第一个参数是要分页的queryset对象，第二个参数是request对象
        ret = page_pagination.paginate_queryset(book_list, request, self)
        #第三步，再序列化的时候用ret对象
        book_ser = BookSerializer(instance=ret, many=True)
        response.msg = '查询成功'
        response.data = book_ser.data
        # return Response(response.get_dic)
        return page_pagination.get_paginated_response(book_ser.data)
 

'''
# 重点参数
-page_size：控制每页显示条数
-page_query_param：控制查询第几页的查询参数,
    -比如page_query_param='xx'
    -http://127.0.0.1:8000/books/?xx=2  表示查询第二页的数据
-page_size_query_param：控制每页最大显示的条数
    -比如page_pagination.page_size_query_param='max'
    -http://127.0.0.1:8000/books/?xx=2&max=6   表示查询第二页的数据,每页显示6条
-max_page_size：控制每页最大显示的条数
    -比如:page_pagination.max_page_size=7
    -http://127.0.0.1:8000/books/?max=1000    最多显示7条
'''
```

## 偏移分页

```python
from rest_framework.pagination import LimitOffsetPagination
class BooksView(APIView):
    def get(self, request):
        response = CommonResponse()
        book_list = models.Book.objects.all()
        # 第二步，实力化产生一个分页类对象，不需要传参数
        page_pagination = LimitOffsetPagination()
        #重点的4个参数
        # page_pagination.default_limit=5
        # page_pagination.limit_query_param='limit'
        # page_pagination.offset_query_param='offset'
        page_pagination.max_limit=10
        # 第一个参数是要分页的queryset对象，第二个参数是request对象
        ret = page_pagination.paginate_queryset(book_list, request, self)
        #第三步，再序列化的时候用ret对象
        book_ser = BookSerializer(instance=ret, many=True)
        response.msg = '查询成功'
        response.data = book_ser.data
        return Response(response.get_dic)
'''
# 重点参数
-default_limit：默认每页显示的条数,默认偏移的数量
    -比如:default_limit=5
    -http://127.0.0.1:8000/books/    就会显示5条数据
-limit_query_param：往后偏移多少条
    -就用默认值:limit
-offset_query_param：标杆值
    -用默认值:offset
    limit_query_param+offset_query_param联合起来用
    -访问:http://127.0.0.1:8000/books/?limit=1&offset=5 表示以数据的第5条作为标杆，往后偏移1条
	-max_limit:最大偏移的条数(最大取出的条数)
'''
```

## CursorPagination 分页

```python
CursorPagination 分页
from rest_framework.pagination import CursorPagination
class BooksView(APIView):
    def get(self, request):
        response = CommonResponse()
        book_list = models.Book.objects.all()
        page_pagination = CursorPagination()
        #重点的参数
        page_pagination.ordering='nid'
        # page_pagination.page_size=3

        ret = page_pagination.paginate_queryset(book_list, request, self)
        book_ser = BookSerializer(instance=ret, many=True)
        response.msg = '查询成功'
        response.data = book_ser.data
        # return Response(response.get_dic)
        return page_pagination.get_paginated_response(book_ser.data)
'''
# 重点参数:
-page_size:每页显示的条数
-cursor_query_param:不需要动
-ordering:按什么排序
'''
```

#### 