[TOC]

# 认证组件

## 认证简介

```python
只有通过认证的用户才可以访问指定的url地址，即校验是否是我的登录用户
```

## 局部使用

```python
'''
局部使用，只需在视图类中加入：
'''
authentication_classes = [TokenAuth, ]
```

models层：

```python
class User(models.Model):
    name=models.CharField(max_length=32)
    pwd=models.CharField(max_length=32)
    choice=((1,'超级用户'),(2,'普通用户'),(3,'穷逼用户'))
    type=models.IntegerField(choices=choice,null=True)
    # typ=models.ForeignKey(to='Type')

# class Type(models.Model):
#     id=models.AutoField(primary_key=True)
#     name=models.CharField()

class UserToken(models.Model):
    token = models.CharField(max_length=64)
    user=models.OneToOneField(to='User',on_delete=models.CASCADE)
```

视图层：

```python
# 新建认证类
----------------------------MyAuth.py--------------------------------------
from rest_framework.authentication import BaseAuthentication
from app01 import models
class MyAuthetication(BaseAuthentication):
    # 重写这个方法
    def authenticate(self,request):
        #认证相关的东西

        # 如果token信息放到请求头中，如何取？
        # request._request.META
        # token=request.META.get('token')

        # 校验该次请求是否携带正确的token
        # 取出token
        token=request.GET.get('token')
        # 校验该次请求是否携带正确的token
        ret=models.UserToken.objects.filter(token=token).first()
        if ret:
            # 正常通过认证的用户
            #ret.user 当前登录用户
            return ret.user,token
            # return None
        else:
            # 没有登录或者非法用户
            raise AuthenticationFailed('您没有通过认证')
            
----------------------------------views.py------------------------------------
from rest_framework.views import APIView
from rest_framework.response import Response
from app01.MyAuth import MyAuthetication

class BooksView(APIView):
    # 局部认证
    authentication_classes=[MyAuthetication]
    throttle_classes=[MyThrottling]
    def get(self,request):
        #request.user就是当前登录用户
        print(request.user)
        print(request.auth)
        return Response('ok')
    
 # 写登录接口
class Login(APIView):
    # 全局使用的局部禁用
    authentication_classes = []
    def post(self,request):
        response={'status':100,'msg':None}
        name=request.data.get('name')
        pwd=request.data.get('pwd')
        #去数据库校验该用户是否存在
        user=models.User.objects.filter(name=name,pwd=pwd).first()
        if user:
            # 正常用户登录成功，返回一个唯一的随机字符串
            token=uuid.uuid4()
            #把生成的随机字符串存到数据库中
            # 这样不行，因为每次登录都会新插入一条
            # models.UserToken.objects.create(user=user,token=token)
            # 先去数据库中查询，如果当前用户存在记录，更新token，如果不存在，新增一条
            # 根据user取查询，如果查到数据更新defaults中的数据，如果查不到，新增一条数据
            ret=models.UserToken.objects.update_or_create(user=user,defaults={'token':token})
            response['msg']='登录成功'
            response['token']=token
        else:
            #用户名或密码错误
            response['status'] = 101
            response['msg'] = '用户名或密码错误'
        return Response(response)
    
```

## 全局使用

```python
# 在setting中配置
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': ['app01.MyAuth.MyAuthetication', ]
}
```

