[TOC]

# 序列化组件

## Django自带序列化组件

```python
# Django自带序列化组件，非常难用，一般不要用
from django.core import serializers
def test(request):
    book_list = Book.objects.all()    
    ret = serializers.serialize("json", book_list)
    return HttpResponse(ret)
```

## rest-framework序列化之Serializer

models部分：

```python
from django.db import models

# Create your models here.


class Book(models.Model):
    nid = models.AutoField(primary_key=True)
    name = models.CharField(max_length=32)
    price = models.DecimalField(max_digits=5, decimal_places=2)
    publish_date = models.DateField()
    publish = models.ForeignKey(to='Publish',to_field='nid',on_delete=models.CASCADE)
    authors=models.ManyToManyField(to='Author')
    def __str__(self):
        return self.name


    def test(self):
        return str(self.price)+self.name


class Author(models.Model):
    nid = models.AutoField(primary_key=True)
    name = models.CharField(max_length=32)
    age = models.IntegerField()
    author_detail = models.OneToOneField(to='AuthorDatail',to_field='nid',unique=True,on_delete=models.CASCADE)


class AuthorDatail(models.Model):
    nid = models.AutoField(primary_key=True)
    telephone = models.BigIntegerField()
    birthday = models.DateField()
    addr = models.CharField(max_length=64)


class Publish(models.Model):
    nid = models.AutoField(primary_key=True)
    name = models.CharField(max_length=32)
    city = models.CharField(max_length=32)
    email = models.EmailField()

    def __str__(self):
        return self.name
```

views部分：

```python
source的三种用法：
1 指定字段
2 指定方法
3 深度查询

===================================MySerializer.py===============================
from rest_framework import serializers
from app01 import models
from rest_framework.exceptions import ValidationError

class AuthorSerializer(serializers.Serializer):
    # nid=serializers.CharField()
    # name=serializers.CharField()
    # age=serializers.CharField()
    class Meta:
        model=models.Author
        fields='__all__'
        
# 现在要序列化book这个表
class BookSerializer(serializers.Serializer):
    nid = serializers.CharField()
    # name = serializers.CharField()
    # 后面source指定要序列化的字段
    title = serializers.CharField(source='name')
    price = serializers.CharField()
    # 显示出版社的邮箱
    publish = serializers.CharField(source='publish.email')
    # source不但可以指定表模型的字段，还可以指定表模型的方法，指定方法的时候，执行该方法，并将返回值付给xx这个变量
    xx=serializers.CharField(source='test')
    #publish字段，返回出版社的所有信息，包括id，name，email。。。。
	#SerializerMethodField配合一个方法，方法的返回值会付给publish
    publish = serializers.SerializerMethodField()
    def get_publish(self, obj):
        # print(type(obj))
        # print(obj)
    	return {'id': obj.publish.pk, 'name': obj.publish.name}
    # 所以的作者详情
    authors=serializers.SerializerMethodField()
    def get_authors(self,obj):
         #取到所有作者
         author_list=obj.authors.all()
         # author_ll=[ {'id':} for author in author_list]
         # 实例化一个作者的序列化类对象
         author_ser=AuthorSerializer(author_list,many=True)
         return author_ser.data
===================================views.py===============================
from app01 import models
from rest_framework.views import APIView
from rest_framework.response import Response
from app01.MySerializer import BookSerializer

class BookView(APIView):
    def get(self, request, *args, **kwargs):
        response = {'status': 100, 'msg': '获取成功'}
        book_list = models.Book.objects.all()
        book_ser = BookSerializer(book_list,many=True)
        response['data'] = book_ser.data

        return Response(response)
```

## rest-framework序列化之ModelSerializer

views部分：

```python
===================================MySerializer.py===============================
from rest_framework import serializers
from app01 import models
from rest_framework.exceptions import ValidationError

class AuthorSerializer(serializers.Serializer):
    class Meta:
        model=models.Author
        fields='__all__'

class BookSerializer(serializers.ModelSerializer):
    class Meta:
        #指定要序列化book这个表
        model=models.Book
        # 指定要序列化的字段
        # fields=['nid','name']
        #序列化所有字段
        fields='__all__'
        #选择要排除的字段（注意，不能跟fields连用）
        # exclude=['name','price']
        #深度，官方建议最多写10，建议最多写3
        # depth=1

    # publish=serializers.CharField(source='publish.name')
    #显示出版社的详细信息
    # publish = serializers.SerializerMethodField()
    # def get_publish(self,obj):
    #     # print(type(obj))
    #     # print(obj)
    #     return {'id':obj.publish.pk,'name':obj.publish.name}
    #
    # #显示所有作者的信息
    # authors=serializers.SerializerMethodField()
    # def get_authors(self,obj):
    #     #取到所有作者
    #     author_list=obj.authors.all()
    #     # author_ll=[ {'id':} for author in author_list]
    #     # 实例化一个作者的序列化类对象
    #     author_ser=AuthorSerializer(author_list,many=True)
    #
    #     return author_ser.data
    # 局部钩子函数，对单个字段校验
    #校验name字段不能以sb开头
    def validate_name(self,value):
        if value.startswith('sb'):
            raise ValidationError('书名不能以sb开头')
        else:
            return value

    #全局钩子函数，对全局字段进行校验
    # def validate(self,a):
    #     # print(a)
    #     name=a.get('name')
    #     price=a.get('price')
    #     if name != price:
    #         raise ValidationError('错了')
    #     else:
    #         return a
    
===================================views.py===============================
from app01 import models
from rest_framework.views import APIView
from rest_framework.response import Response
from app01.MySerializer import BookSerializer

#获取单本图书的接口
class BookView(APIView):
    def get(self, request, pk,*args, **kwargs):
        response = {'status': 100, 'msg': '获取成功'}
        #取到pk为传入的pk的书，book对象
        book = models.Book.objects.all().filter(pk=pk).first()
        #要序列化单条，many=False
        book_ser=BookSerializer(instance=book,many=False)
        # book_ser=BookSerializer(book,many=False)
        response['data']=book_ser.data


        return Response(response)

    #修改某本书
    def put(self,request,pk):
        response = {'status': 100, 'msg': '修改'}
        book=models.Book.objects.filter(pk=pk).first()
        #修改
        book_ser = BookSerializer(instance=book,data=request.data)
        if book_ser.is_valid():
            book_ser.save()
            response['data']=book_ser.data
        else:
            response['msg']=book_ser.errors
        return Response(response)
```

