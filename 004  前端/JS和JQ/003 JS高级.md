# JS高级

## 一、函数高级

#### 1、函数回调

```js
// 回调的函数
function callback(data) {}
// 逻辑函数
function func(callback) {
    // 函数回调
    if (callback) callback(data);
}

// 函数回调的本质：在一个函数中(调用函数)，当满足一定条件，调用参数函数(回调函数)
// 回调函数作为调用函数的参数传入
// 回调函数通过参数将调用还是内部数据传出
```

#### 2、闭包

```js
function outer() {
    var data = {}
    function inner() {
        return data;
    }
    return inner;
}

// 闭包目的：不允许提升变量作用域时，该函数的局部变量需要被其他函数使用
// 闭包本质：函数的嵌套，内层函数称之为闭包
// 闭包的解决案例：①影响局部变量的生命周期，持久化局部变量；②解决变量污染
// 闭包：函数嵌套定义，内部函数引用了外部函数的局部变量，外部函数中返回内部函数
```

## 二、循环绑定

```html
.html文件
<ul>
	<li>列表项</li>
    <li>列表项</li>
    <li>列表项</li>
</ul>
```

```js
.js文件
var lis = document.querySelectorAll('li');
for (var i = 0; i < lis.length; i++) {
    lis[i].onclick = function () {
        // 打印列表项的索引
		console.log(i);
	}
}
// 会造成变量污染
// 获取局部作用域解决
//解决办法 1、闭包解决 2、对象属性解决,给每个li对象加一个属性来存i
 var lis = document.querySelectorAll('li');
    for (var i = 0; i < lis.length; i++) {
        (function (i){
        lis[i].onclick = function () {
            // 打印列表项的索引
        console.log(i);
	    }
    })(i)
    }
```

## 三、面向对象JS

#### 1、属性与方法

```js
//绑定式定义对象
var obj = {}; | var obj = new Object();
// 属性
obj.prop = "";
// 方法
obj.func = function () {}
// 删除属性与方法
delete obj.prop
delete obj.func
```

#### 2、类字典结构使用

- 结构

```js
var dict = {name: "zero", age: 18}
```

- 拓展

```js
var dict = {"my-name": "zero", fn: function () {}, fun () {}}
```

- 使用

```js
dict.name | dict["my-name"] | dict.fn()
```

#### 3、构造函数（`ES5`）

```js
// 创建一个构造函数定义对象
function People(name, age) {
    this.name = name;
    this.age = age;
    this.eat = function () {
        console.log('吃')
    }
}
//用构造函数创建一个People
p = new People('小明'，18)
p.eat()
```

#### 4、原型模式

```
function Person1(name,age){
	this.name = name
	this.age  = age
}
//在构造方法外通过原型链绑定一些新的属性和方法
Person1.prototype.address = "北京"
Person1.prototype.walk =function(){
	console.log("let's go")
}
p = new Person1("yu",18) //此时创建的p对象上，除了有构造函数中的属性与方法以外还有原型链上的属性和方法
```



#### 5、继承（`ES5`）

```js
// 父级
function Sup(name) {
    this.name = name;
    this.fn = function () {
        console.log('fn class');
    }
}
// 原型  
console.log(Sup.prototype);
console.log(Sup.__proto__);

// 子级
function Sub(name) {
    // 继承属性
    Sup.call(this, name);
}

// 继承方法
Sub.prototype = new Sup;

// 创建子级对象
var sub = new Sub("subClass");
// 使用属性
console.log(sub.name);
// 使用方法
sub.fn();

// 指向自身构造函数
Sub.prototype.constructor = Sub;
```

#### 6、类及继承（`ES6`）

```js
// 父类
class People {
    // 构造器
    constructor (name, age) {
        this.name = name;
        this.age = age;
    }
    // 实例方法
    eat () {
        console.log('吃吃吃');
    }
    // 类方法
    static create () {
        console.log('诞生');
    }
}
// 子类
class Student extends People {
    constructor (name, age) {
        // super关键词
        super(name, age)
    }
}
```

## 四、定时器

- `setInterval` 按照指定的周期(以毫秒计)来调用函数或计算表达式。方法会不停地调用函数，直到`clearInterval `被调用或窗口被关闭

```html
<!--
语法 setInterval(code,millisec,lang)
code 必需，要调用的函数或要执行的代码串
millisec 必需，周期性执行或调用code之间的时间间隔，以毫秒计
lang  可选 JScript | VBScript |JavaScript
-->
<html>
<body>
    <!-- 用来显示时间的input框 -->
<input type="text" id="clock" /> 
    
<script type="text/javascript">
    
var qwe=self.setInterval("clock()",1000);

//定义一个获取当前时间的函数，格式是下午7:10:44
function clock(){
	var d=new Date();
	var t=d.toLocaleTimeString();
document.getElementById("clock").value=t;
}
</script>

<button onclick="qwe=window.clearInterval(qwe)">停止</button>

</body>
</html>
```

- `setTimeout`   在指定的毫秒数后调用函数或计算表达式。

```
语法： setTimeout(code,millisec,lang)
code 必须 要调用的函数后或要执行的JavaScript代码串
millisec 必须，在执行代码前需等待的毫秒数
lang  可选，脚本语言可以是:JScript | VBScript |JavaScript
```

```html
</head>
<body>

<p>点击按钮，在等待 3 秒后弹出 "Hello"。</p>
<button onclick="myFunction()">点我</button>

<script>
function myFunction(){
    setTimeout(function(){alert("Hello")},3000);
}
<!--   注意不能 setTimeout(alter("hello"),3000)偷懒，直接就执行了，不延迟3秒 -->
</script>
</body>
```