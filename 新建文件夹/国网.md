1、`__all__`暴露接口用的

2、`pprint` 数据输出美化

3、`sqlalchemy`使用count()函数的优化，scalar()

```
#原有
count = LoginLog.query.filter(LoginLog.status == 0).count()
#SQL语句
SELECT
    count(*) AS count_1
FROM
    (SELECT status FROM loginlog WHERE AND status=0) 
#进行了一次子查询，会生成临时表，效率低
```

```
#优化代码
count = db.session.query(func.count(LoginLog.id)).filter(LoginLog.status == 0).scalar()
SELECT 
	count(loginlog.id) AS count_1
FROM
    loginlog
WHERE
    loginlog. STATUS = 0
```

4、导出`xlsx`

```
response.headers["Content-Disposition"] = "attachment;filename={}".format(quote(title.encode('utf-8')))    #以附件还是内联显示
response.headers['Content-Type'] = 'application/x-xlsx'  #x-xlsx输出
```

5、

```
app.cache.set('all_system_user', all_users, format='json', ex=24 * 60 * 60) 中  all_users存的是角色名和类型
```

6、

```
 db.session.expunge(ret)，断开查询结果与session的关系。让它成为一个本地实体，不会从缓存中清除，使用时候，就不会再查询
```

7、`csrf`这个项目中用的是装饰器

```
def generate_csrf_token(f):
    @functools.wraps(f)
    def decorated_function(*args, **kwargs):
        _generate_token()
        return f(*args, **kwargs)

    return decorated_function
    
    
def _generate_token(token=None):
    token = token or token_uuid()
    if 'csrf_token' not in session:
        session['csrf_token'] = token
        session['csrf_timeout'] = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
```

8、

```
synchronize_session用于query在进行delete or update操作时，对session的同步策略
-False - 不对session进行同步，直接进行delete or update操作。
-fetch - 在delete or update操作之前，先发一条sql到数据库获取符合条件的记录
```
