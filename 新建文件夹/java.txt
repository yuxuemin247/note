java的跨平台性(跨操作系统)，JVM(java虚拟机)
JRE java运行环境
JDK java开发工具包
JDK > JRE > jvm
oracle.com 

编写源代码   xxx.java
编译成字节码  xxx.class(javac.exe)
运行(java.exe)·
.java -> java编译器编译为.class ,再通过虚拟机解释器解释执行
javaSE 标准版
javaEE 企业版，是SE的扩展。

//单行注释信息
/*  
多行注释信息
*/

java关键字：
一些特殊含义，被保留了

java基本数据类型：4类8种 
整数型    byte short int long
浮点型、 float double
字符型、 char
布尔型     boolean
      引用数据类型：字符串，数组，类，接口，lambda

变量
数据类型  变量名=值

int num = (int) 100L
所有源代码都在src下面
包是一组文件夹的集合，多层级文件夹
java方法定义不能嵌套，
完整方法定义，若干语句的功能集合，输入参数和返回参数
修饰符 返回值类型 方法名称(参数类型，参数名){
方法体；
return #第一停止方法，第二将返回值还给调用值，return的返回值要与方法名前面的返回值类型对应

}
public static 
返回的数据结果类型
方法应该定义在类当中，
方法调用：单独调用 方法名称(),打印调用，赋值调用

void定义的方法，无返回值类型。函数只能单独调用，不能进行打印调用或者赋值调用


数组：一种引用数据类型，内容类型统一，数组长度在程序运行期间不能改变
初始化：
1、动态初始化（指定长度）
	数据类型[] 数组名称 =new 数据类型[数组长度]；
2、静态初始化（指定内容)，长度就是元素的个数，会自动推算
	数据类型[] 数组名称 = new 数据类型[]{
 元素1，元素2
}；

3、省略格式
     书记类型[]  名称 = {}；

直接打印数组名称，得到的是数组对应的内存地址哈希值
访问数组元素的格式：
数组名称[索引值]



4、java的内存划分
  栈(stack):存放的都是方法中的局部变量(方法的参数，或者方法{}内部的变量)一但超出作用域，立刻从栈内存消失。方法的运行一定要在栈当中
  堆(heap)内存：凡是new出来的东西，都在堆内存当中。堆内存的值都有一个地址值：16进制。堆内存里的数据都有默认值；整数0，浮点数0.0，字符'\u0000' 布尔flase 引用类型 null

  方法区(method area) 存储.class相关信息，包含方法的信息
 本地方法栈 与操作系统相关
 寄存器(pc Register) 与cpu相关

函数的参数可以是数组
public static void f1(int[] array)

成员变量定义在类里面，方法外卖呢
成员方法定义不要static关键字
成员方法(方法)
public void study() {}

对象创建、1、导包  2、new

泛型只能是引用类类型（地址），不能是基本类型
自动装箱，自动拆箱

基本类型 要用 包装类
byte   Byte
short Short
int     Integer
long  Long
float  Float
double Double
char  Character
boolean Boolean


ArrayList

threading的信号量 semaphore，是用于控制进入数量的锁
#文件读写 ，一个写，10个读

Java 继承
抽取共性，代码复用
public class 子类名 extends 父类名{

}
在父子类的继承关系当中，如果成员变量重名，创建子类对象时，访问由



抽象方法：在父类中定义了，但太抽象了，不够具体，父类不好实现，在子类中实现。
直接加上abstract关键字，然后去掉关键字，直接分号结束。

抽象类：抽象方法所在的类，必须是抽象类才行，在class之前加上abstract 即可
public class Animal {

// 这个一个抽象方法，代表吃东西，但是具体吃什么(大括号内容) 不确定
public  abstract void eat() 

// 不能直接创建抽象类对象，必须用一个子类继承抽象类，子类必须覆盖重写(实现)抽象方法。
 去掉abstract，写{}方法体 即可


接口：接口就是一种公共的规范标准。

接口就是多个类的公共规范
public interface  接口名称 {
  //常量、抽象方法、默认方法、静态方法、私有方法

  //抽象方法(public 和abstract 两个关键字都可以省略)
 public abstract void methodAbs1();

 # 默认方法可以解决接口升级的问题.(如果接口升级添加的新的抽象方法，所有的实现类都要添加，所以由默认方法)
 public default void  methidAbs2() {
   System.out.printIn("我是默认的方法")
}

}

interface   .java 编译生成的还是 .class文件

接口使用步骤：
1、接口类不能直接new对象使用，必须一个实现类 来实现 该 接口
public class 实现类名称  implements 接口名称 {
}
2、接口的实现类必须覆盖(实现)接口所有的抽象方法

接口小结：
 1、成员变量其实是常量 格式：
public static final 数据类型 常量名称 = 数据值
2、 接口中最重要的就是抽象方法 ：格式
public abstract 返回值类型 方法名称(参数列表)
注意：实现类必须覆盖重写接口所有的抽象方法，除非实现类是抽象类

3、从java8开始，接口里可以定义默认方法：
public default 返回值类型 方法名称(参数列表) {
方法体
}
默认方法可以覆盖重写
4、从java8开始，接口里可以定义静态方法 格式：
public static 返回值类型 方法名称(参数列表) {
}
应该通过接口名称进行调用，不能通过实现类对象调用接口静态方法

5、从java9开始，接口允许定义私有方法 格式：
普通私有方法： private 返回值类型 方法名称(参数列表) {方法体}
私有静态方法： private static 返回值类型 方法名称(参数列表) {方法体}
private 的方法只有接口自己才能调用，不能被实现类或其他调用


类与接口的关系
类与类之间是单继承的，直接父类只有一个
类与接口之间是多实现的，一个类可以实现多个接口
接口与接口是多继承的

多态 多态指的是对象。一个对象拥有多种形态。 有类的形态，也有父类的形态

父类名称 对象名 = new 子类名称()
左侧父类的引用，指向了右侧子类的对象

向上转型 ： 
父类名称 对象名 = new 子类名称()
向下转型：还原本来的类型
子类 对象名 = （子类名称） 子类对象