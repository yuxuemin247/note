sentry   错误信息收集

dynaconf  敏感信息
import sys
sys.setrecursionlimit(10000)  #修改递归深度
sysbench 测试整机性能的工具
flower 监控

用主键查询
深入浅出mysql
explain 执行计划 分析
B+数 默认是3层结构
主键索引是唯一索引，聚集索引（B+数），最快
非聚集索引，根节点的叶子 保存的是主键，在查询一次主键 得回表查询，也很快
select_type  简单查询还是复杂查询 
table    表
partitions 数据分区，建表时候  RANGE,hash
type  const 常量 > eq_ref > ref > range >index >all

django-filter

视图里
 filter_backend =(DjangoFilterBackend)
filter_fileds = ('字段1','字段2','字段3')

installedapps 
	django_filters 
只能精准查询

或者自定义（模糊查询）
class XXX(filterset.FilterSet):
      name =filterset.CharFilter(lookup_expr = 'startwith')
      minhot = filterset.NumberFilter(field_name='hot',lookup_expr='gte')
      maxhot = filterset.NumberFilter(field_name='hot',lookup_expr='lte')
      dist = filterset.NumberFilter(field_name='district')
      
static
public
resource

tornado不用多线程，多进程。就是单进程，异步。io协作式并发。
tornado 其他库也要用异步化的三方库。

concurrent.future  不会阻塞
在将来的时候用future 获取执行结果

fetch('/api/districts/').then(resp => resp.json()) .then(json => this.provices = json.results)


面向对象的设计原则：
      1、单一职责原则（SRP）
      2、开闭原则(OCP)- 对扩展开放，对修改关闭。-一定要有抽象类，形成继承结构。抽象化和封装可变性
      3、依赖倒转原则(DIP)   - 面向抽象编程（面向接口编程）-尽可能使用抽象类型让系统有扩展性（对JAVA很重要） X
      4、里式替换原则(LSP)   -能用父类型的地方一定可以使用子类型（考察继承结果的合理性，不满足里式替换原则的继承是不能够成立的）
      5、接口隔离原则(ISP) -没有接口这个概念，接口要小而专，不能大而全（高内聚）x
      6、合成聚合复用原则(CARP) - 优先使用强关联而不是继承关系复用代码(has )
      7、迪米特法则 - 不要跟陌生人讲话(不要乱发消息)  低耦合

      SOLID 原则 = SRP + OCP +LSP +ISP +LOD

      GOF 23种场景(设计模式) --在python里已经被弱化

      单例 ： 无状态/特定属性  有状态/属性但是是共享的
      FLASK中的G对象
      装饰器其实是代理模式，用一个装饰器代理另一个函数.(并不是装饰器模式)
      工厂模式：
a
      实现服务化架构 --> SOA/ SaaS /PasS
       1、RPC   远程过程调用(python的nameko框架)
       2、webService  --->(SOAP协议)
       3、RESTFUL  --->  HTTP  Stateless / Horizontal Scaling

      
      JWT  JSON web Token  --->防伪造防篡改
      pip install pyjwt  
         encode()  /  decode()

      with atomic()  事务控制

      使用redis限制短信验证码的发送次数
      
      CELERY上传图片的序列化问题,修改celery默认序列化为json,修改为pickle。
      jpg/png/ 有些图片上传可以显示,有些图片不可以显示（有可能）


      rabbitMQ 
      发送消息时指定Q
      队列
      X 交换器
          fanout
          direct  去指定的队列，Q1
          topic   可以模糊匹配
          headers
      配置那个匹配规则挺麻烦了。
    - 核心概念
      队列(Queue)： 存储消息的对象
      交换器(Exchange)：负责将消息路由到一个或多个队列中
      路由键(RoutingKey匹配，将消息路由到对应的队列)：生产者为消息绑定的键，用来指定消息的路由规则
      绑定键(Binding Key)：与 RoutingKey匹配，将消息路由到对应的队列
    - 配置管理 --> rabbitmq-ctrl
      -添加/删除/查看虚拟主机
      add_vhost /list_vhosts /delete_vhost
      -创建删除用户/修改密码/分配角色
      add_user /change_password /delete_user /list_users /set_user_tags
      - 分配/清理/查看用户权限()

      rabbitmq预留了很多端口给扩展用，比如 15672端口，可视化查看 ，25672集群


      celery 如果序列化的是JSON， 就可以跨语言执行
            pickle序列，就不可以跨python,java执行

用户身份认证和授权：
1、ACL       -----Access control list 访问控制列表  访问白名单/访问黑名单
2、RBAC    -----基于角色的访问控制 
  user ---role  --privilege --Resource

JWT有三部分: header  payload 负载(用户标识和过期时间)  signature签名
  头部包含了两部分

DRF 跟 django的耦合性很高，比如它那个登录用户限流。获取cacahe_key时，user必须django里的user，必须有is_authencat


@lru_cache(maxsize=256)  #maxsize最大缓存结果
python内置，缓存执行结果

#斐波拉契数(递归写法)  几何级数 2**n，并且产生了大量重复的计算
def fib(num):
  if num in (1,2):
    return 1
  return fib(num-1) +fib(num-2)

#动态规划，保存了中间执行结果
def fib(num,temps={}):
  if num in (1,2):
    return 1
  if num not in temps:
    temp[num] =fib(num-1) +fib(num-2)
  return temps[num]

@lru_cache()
def fib(num):
  if num in (1,2):
    return 1
  return fib(num-1) + fib(num-2)


cprofile/

项目的三大架构 
    项目的简短描述(定性)。
    1、业务架构
        Xmind  --> 模块  --> 大用户故事 ---> 小用户故事 -->需求池(未完成，进行中，已完成)
        垂直拆分  --> 分功能模块(app)  -->每个模块相对独立，松散耦合
        水平拆分  --> 分代码职责   --> 模型(持久化)、业务逻辑、控制器

    2、技术架构
        前端(大前端，多端):
        SPA -single page Application /
        ~ Vue.js / React  渲染界面
                              JQuery、Bootstrap响应式适配它没有分模块
        
        移动端
            原生开发：
            ~ Android : Java / Kotlin
            ~ ios : objective-c/ Swift
            跨平台开发：
            ~ React Native 打包成安卓和apple
            ~ uni-APp
            ~ Flutter 接近于原生开发

        后端
         ~ Django(重量级)/Flask(轻量级)/sanic() /Tornado(单线程+异步IO,长链接高并发)

         Django生态圈：
          djangorestframework /django-redis /django-filter
          django-imagekit /django-storages
          django-celery(直接用celery比较好)
          pymysql/mysqlclient
          logutils
          sentry错误信息收集
          cookiecutter
          bap

          安装方面：
          pycrypto /pyjwt /itsdangous
          测试：
            pytest
          时间：
          python-deteutil

          django-haystack

          pylint
          pyymul

        Flask生态圈 : flask-sqlachemy /flask-restful

        tornado:  aiomysql / aioredis / motor /
      数据库：
        mysql /postgreSQL /oracle
        Redis /MongoDB  /Elasticsearch

        消息队列:
          Redis /rabbitmq /kafka
        邮件服务器：购买邮件服务/自己搭sendmail|postfix
        搜素引擎：ELasticSearch | solr
        静态资源服务 qiqiu /s3/ oss
        监控服务：zabbix | promethus

        三方服务：存储服务，短线，邮箱


        SELECT count(*) as count FROM students WHERE gender=0 AND name is null  GROUP BY GRADE ORDER BY count

      物理架构(项目怎么部署)
      反向代理：
        1、保护真正的服务器不暴露在公网
        2、配置负载均衡策略(应对高并发)
        Nginx除了web服务器，也可以做反向代理
        lvs 也可以
        硬件F5/A10也可以负载均衡
      
      主机+备机(Keeplived-热切换) 防止代理服务器挂掉

      WEB服务器处理静态资源的请求(html、css、js)
        apache
        nginx 
        WSGI就是解决web服务器和应用服务器的通信
        python和java走的是WSGI(WEB服务接口)  c、c++用的是CGI(公共服务接口)
      应用服务器 动态内容生成：
         uwsgi
         gunicorn
         tomcat(java开发)


          VPC + 交换机 + NAT(网络地址转换) 
          跳板机 公网只能连跳板机

      元类 :
       对象是通过类创建出来的，类是通过元类创建出来的
       ~定义抽象类的元类： abc模块的ABCMeta
       ~定义抽象方法： abc模块的abstractmethod装饰器
       ~抽象类不能实例化
      #要继承type ,继承自type的类才是元类
      class SingletonMeta(type):
            def __init__(cls,*args,**kwargs):
              cls.__instance =None 
            def __call__(cls,*args,**kwargs):
               if not cls.__instance:
                  cls.__instance =
                return cls.__instance

并发编程：
  1、多线程(thread)，受到全局解释器锁(GIL)，并不能使用多核特性(就算8个核也是一个跑),但不代表多线程不能提升效率，并不适合计算密集型应用。
  2、多进程(process/fork)  适合计算密集型任务，可以用到多核特性
  一般都要使用线程池，进程池
  3、异步编程(异步IO) 
        -协程(只有一个线程,相互协作多个子程序,协作式并发,提高了Cpu的利用率，用户态的切换)
        -
  I/O密集型，3是更好的选择 

python解释器:
  1、CPython,底层利用C语言 malloc/free,并不是线程安全的。有GIL
  2、pypy   有GIL
  3、Jython 就没有全解释器锁

被多个线程竞争的资源，通常需要加锁保护否则状态错乱

关系型数据库面对并发数据访问
  数据更新
  1、第一类丢失更新
  2、第二类丢失更新
  数据读取
  3、脏读
  4、不可重复读
  5、幻读
  只有锁才能解决上述问题，但锁操作不方便。所以在关系型数据库是通过设置事务隔离界别，数据库为我们选择合适的锁

  READ UNCOMMITED 读未提交 只能避免1 
  READ COMMIITed  读提交，避免脏读
  REPEATABLE READ  

  可以根据需要调整当前 事务的隔离级别，而不是调整全局的


  可重入锁 
  RLock()
  condition 线程调度(线程相互通知,基于锁)
  线程池，进程池
  concurrent.future
  
  #daemon =True 守护线程，主线程结束全结束了
  创建启动线程的三种方式：
   1 、 Thread(target= ,args=(),).start()
   2、  继承Thread类重写run方法自定义线程类，创建对象用start()方法启动
   3、  通过线程池 concurrent.future.ThreadPollExector对象的submit/map 方法把任务交给线程

   创建进程除了上面三种还有fork子进程


   线程：操作系统分配CPU的基本单元
   进程：操作系统分配内存的单元

   运行一个程序 包含一个或多个进程，每个进程里面包含一个或多个线程，至少有一个主线程。

   多线程：占用更多的CPU运行时间(时间片)
   多进程：占用更多的CPU 或者更多的核

   异步编程： 提升CPU的利用率(分配到它这个线程时，不让CPU时间在闲置中浪费(IO))
   from fun
   def display(num):
      time.sleep(1)
      print(num)
  fs = [partial(display,i) for i in range(10)]



aysnc  3.7关键字  不是普通函数，拿到的是协程对象
import time
from functools import partial
import  asyncio

#加了 async 就不是普通对象
async  def display(num):
    await asyncio.sleep(1)  #不能用 time.sleep() 了
    print(num)

#返回了协程对象
# co = display(1)
# print(co)


#装了10个协程对象
cos = [display(i) for i in range(10)]
print(cos)
# 运行要在事件循环(这用的是系统默认的事件循环) ，还有更好的事件循环uvloop  
loop = asyncio.get_event_loop()
#asyncio.set_event_loop_policy(uvloop.EventLoopplicy) #更换成 uvloop事件循环
#只能放一个任务，所以用 asyncio.wait 把任务列表编程一个个任务
loop.run_until_complete(asyncio.wait(cos))
#关闭事件循环
loop.close()


uvloop事件循环
yum install -y libuv libuv-devel
pip install uvloop


GO 语言的协程更像python的线程

实现两个 Goroutine通信，要求如下：
（a) 实现ping-pong 效果
 (b) 在第三个Goroutine中查找前两个Goroutine



def output(content:str):
  counter = 0
  while True:

~装饰器的作用：
  ~参数检查/缓存/代理/上下文提供者



写程序的终极原则：high cohession,low coupling
import time 

def decorate(func):
    def wrapper(*args,**kwargs):
      start = time.time()
      result = func(*args,**kwargs)
      print(f'{func.__name__}:{time.time()-start})
      return result
    
    return wrapper

vim录制宏
rpm -ivh 

异步方式连接的库
 ~aiohttp 支持异步IO的 
  