1、如何避免客户端重复下订单
客户端生成订单时就生成一个唯一的key(uuid)连通订单数据一起发送到服务器，一直等待服务器响应，直到订单成功或者订单失败或者超时。如果超时，向用户提示下单超时，重试还是返回。如果点击重试，还会用这个dedup key 来下单，直到用户返回，或者用户放弃。
后端在订单表中就增加一列，并设置唯一约束。然后下单来了就可以判断key 然后返回一个新订单或者已经存在的单。
2、mysql的隔离级别
读未提交   事务b读取事务a尚未提交的数据，有可能出现脏读
读已提交   oracle ,sql server   我们mysql一般也会用读以提交     ，有可能造成不可重复读   A事务读，同时b事务修改，A再去读，两次数据不一致了
可重复读   mysql默认    可能出现幻读
串行化    每次读操作都会加锁，一般是使用mysql自带分布式事务功能时才使用该隔离级别，是XA事务，是强一致性事务，性能不佳。互联网的分布式方案，多采用最终一致性的事务解决方案。

mysql binlog的格式有三种 
statement     记录的是修改SQL语句
row              记录的是每行实际数据的变更
mixed          上述两者的混合

主从复制是基于binlog复制的(可以简单理解未一个记录数据库更改的文件把）

读已提交和 binlog的statement（mysql 5.0以前没有其他）在进行主从复制时 会出现主从不一致性 
原因在主机上 一个事务先删除，另一个事务插入。而在binlog中它记录的是先插后删，从机执行顺序和主机不一致，就会出现主从不一致。

在读已提交下，主从复制用binlog的row行复制.

为什么不用 串行化 和读未提交呢？
串行，每个操作都会加锁。性能很低

在可重复读界别下，存在间隙锁，防止其他事务插入数据
在读已提交的情况下，不存在间隙锁，其他事务时可以插入数据的，出现死锁的概率比RR低

可重复读的隔离级别下，未命中索引会锁表
在读已提交的隔离级别下，未命中索引只锁行

3、redis的响应延迟问题排查
	1、redis-cli --latency  -h 'host' -p 'port'  看一下平均延迟
	2、查看是不是一些大数据集的 交集，差集之类的。
	3、查看redis的slow log来监控慢操作
	4、或者用top这些看redis进程的cpu使用率，如果traffic不高，八成说明有慢操作
	5、查看是不是持久化文件RDB和AOF重写  fork进程产生的
	6、swapping(操作系统分页）引起的延迟
redis采用了单线程的设计，所以所有的请求是顺序处理的，这和node.js的工作方式很像。

redis 2.6版本引进了redis看门狗(watchdog)软件，这是个调试工具用于诊断redis的延迟问题

4、django + uWSGI + Nginx 
django 提供的是一个开发服务器，在安全上和效率上都是不行的
uWSGI 是一个全功能的 HTTP 服务器，他要做的就是把 HTTP 协议转化成语言支持的网络协议。比如把 HTTP 协议转化成 WSGI 协议，让 Python 可以直接使用。
WSGI 是一种协议，不是任何包不是任何服务器，就和 TCP 协议一样。它定义了 Web 服务器和 Web 应用程序之前如何通信的规范
uwsgi 是一种 uWSGI 的内部协议，使用二进制方式和其他应用程序进行通信。
Nginx 是一个 Web 服务器其中的 HTTP 服务器功能和 uWSGI 功能很类似，但是 Nginx 还可以用作更多用途，比如最常用的反向代理功能。
Nginx 厉害啊，比如静态文件处理，反向代理，负载均衡等。
5、CGI common gateway interfece 通用网关接口    CGI定义了Web服务器与程序间通信的接口标准，使Web服务器可以通过CGI接口执行程序，完成动态请求的处理
lamp linux apache myql php 
6、node.js = 运行环境 + javaScript模块库
个人理解异步就是回调，等通知，同步就是自己时不时去看看
同步/异步：形容一次方法的调用，在单线程中。描述的是执行者是否具备主动通知功能
 阻塞/非阻塞：调用者是否可以执行多个任务，在多个线程中。描述的是调用者的多个线程是否可以同时执行
Node.js 库的异步 和事件驱动的API全都是异步就是非阻塞
非常快的v8引擎，node.js库代码执行非常快
单线程但高度扩展，使用具有循环时间单线程模型。事件机制有助于服务器在一个非阻塞的方式响应并使得服务器高度扩展，而不是创建线程限制来处理请求的服务器
