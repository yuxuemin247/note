1、把10240转成16进制，不要使用hex函数
def toHex(self, num: int) -> str:
    hex_dict = {0: '0', 1: '1', 2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7', 8: '8', 9: '9', 10: 'a', 11: 'b',
                12: 'c',
                13: 'd', 14: 'e', 15: 'f'}
    lis = []
    if num == 0:
        return '0'
    else:
        if num < 0:
            num += 2 ** 32
        while num > 0:
            lis.append(hex_dict[num % 16])
            num //= 16
        lis.reverse()
        return ''.join(lis)

2、给定一个数组arr,在O(n)时间内，求第二大的数。不能使用内置排序方法
def find_k(test_list, k):
    flag = test_list[0]
    test_list.pop(0)
    l_list = [i for i in test_list if i < flag]
    r_list = [i for i in test_list if i >= flag]

    if len(r_list) == k - 1:
        return flag
    elif len(r_list) > k - 1:
        return find_k(r_list, k)
    else:
        k = k - len(r_list)
        return find_k(l_list, k)
test_list = [5, 4, 3, 2, 1, 10,10, 20, 100]
res = find_k(test_list, 1)
print(res)


3、有一张表Email，写一个SQL语句，找出email重复的行
select *  from Email  where email in
  (select  email  from Email  group by email  having count(email)>1)

4、一个订单支付了两次怎么处理
只能异常处理，退款了。
可以设置支付接口延迟设置，
5、事务就是一串SQL语句的集合，要不全部执行成功，要不就全部执行失败。可以保持逻辑数据一致性与恢复性。
事务具有原子性，一致性，隔离性，持久性（事务提交之后，数据是永久性的，不可再回滚）
SQL中默认的是自动提交事务，每一条语句就被看作是一个事务在处理。
显示事务：由Begin Transcation开启事务开始，由Commit Transaction提交事务 Rollback Transaction  出错 回滚 Save Transaction 事物内部的保存点
隐式事务：使用Set IMPLICIT_TRANSACTIONS ON将隐式事务模式打开，不用Begin Transaction开启事务，当一个事务结束，这个模式会自动启用下一个事务，只用Commit Transaction 提交事务、Rollback Transaction回滚事务 。最后SET IMPLICIT_TRANSACTIONS OFF关闭隐式事务。

6、描述一下用户登录过程
用户输入用户名密码等信息，然后post请求，提交到后台。后台取出数据，与数据库中的数据验证，匹配成功，就算登录成功，生成session，并且将利用response设置session_id，一起传到客户端，客户端将session_id存入cookie中，下次请求时会携带。或者token和jwt都类似。


不同服务器之间同步用户的状态
	1.利用数据库同步会话  
	这种方法是把存放会话的表和其他数据库表放在一起，如果mysql也做了集群了话，每个MySQL的节点都要有这张表，并且这张会话表的数据表要实时同步。 
	说明：用数据库来同步会话，会加大数据库的负担，数据库本来就是容易产生瓶颈的地方，如果把会议还放到数据库里面，无疑是雪上加霜
	2，利用cookie 
	将session加密，里面包含有用户信息，保存到客户端cookie中，flask如果不使用session扩展默认就是这样存的。
	缺点：浏览器禁用了cookie了就失效了，而且虽然加密了，但保存大客户端也不太安全。
	3，利用memcache同步会话 
	memcache可以做分布式，如果没有这功能，他也不能用来做会话同步。他可以把web服务器中的内存组合起来，成为一个“内存池”，不管是哪个服务器产生的sessoin都可以放到这个“内存池”中，其他的都可以使用。
	优点：以这种方式来同步会话，不会加大数据库的负担，并且安全性比用饼干大大的提高，把会话放到内存里面，比从文件中读取要快很多。  
	缺点：内存缓存把内存分成很多种规格的存储块，有块就有大小，这种方式也就决定了，内存缓存不能完全利用内存，会产生内存碎片，如果存储块不足，还会产生内存溢出。
	4、JWT



9、工厂函数顾名思义是产生函数的工厂，其实它是产生类实例，把一个需要传入很多参数的类封装，不同使用者只需要传入很少的参数就能调用，一个超类，一个子类（子类决定实例化的类）。
10、商品排序
可综合考虑转化率、好评率、活动推荐、销量和人气，再加上置顶功能，即可设置出相对合理的商品列表排序方案