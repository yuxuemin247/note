1.写一个可以计算被装饰器函数运行时长的装饰器（要能返回被装饰器函数运行的时长和被装饰器函数本身的返回结果，格式自定义）

```python
def get_number():
    time.sleep(2)
    return 66
```

```python
import time


def new_func(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        ret = func(*args, **kwargs)
        end_time = time.time()
        run_time = end_time - start_time
        data = [run_time, ret]
        return data

    return wrapper


@new_func
def get_number():
    time.sleep(2)
    return 66


print(get_number())
```



2.创建一个expense表，三个字段，name字段（string），rate字段 (float)，description（描述）：

2.1：自行创建 n 条数据，写一个根据 rate 排序的查询功能接口（接口需要可以演示调用成功）；

2.2：写一个把数据库中的数据 rate 字段全部改成 1000 的更新功能接口（注意：需要用数据量很多的时候的更新处理方法，可以用 orm ，也可以用原生的sql语句）（接口需要可以演示调用成功）



3和4题选做一题：

3.现在有一个列表和一个元组，list1 = ['key1', 'key2', 'key3'] 和 tup1 = ('1', '2', '3')，把他们两个合成一个字典

```python
list1 = ['key1', 'key2', 'key3']
tup1 = ('1', '2', '3')
a = dict(zip(list1, tup1))  # zip 接受任意多个序列作为参数，返回tuple列表：# [('key1', '1'),('key2', '2'),('key3', '3')]
print(a)
```



4.考虑下面的股票名和价格的映射字典：prices = {"ACME": 45.23, 'AAPL': 612.78, 'IBM': 205.55, 'HPQ': 37.20, 'FB': 18.75}

4.1：查找最小和最大股票价格和股票值的代码

4.2：按照价格对股票名称和价格映射字典做排序（升序）

```python
prices = {"ACME": 45.23, 'AAPL': 612.78, 'IBM': 205.55, 'HPQ': 37.20, 'FB': 18.75}

# 4.1
a = [i for i in prices.values()]
max_a = max(a)
min_a = min(a)
print(max_a)
print(min_a)

# 4.2
li = dict(sorted(prices.items(), key=lambda i: i[1]))
print(li)

```

